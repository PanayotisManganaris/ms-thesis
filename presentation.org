#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:("TODO" "DONE" "NEXT") tex:t
#+options: timestamp:t title:t toc:t todo:nil |:t
#+title: \Huge{}Machine Learning Perovskite Bandgaps for Improved Photovoltaics
#+author: \large{}Panayotis Manganaris\inst{1}
#+email: panos.manganaris@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.2 (Org mode 9.5.5)
#+cite_export: biblatex
#+bibliography: local-bib.bib
#+latex_class: beamer
#+latex_class_options: [10pt, aspectratio=169, presentation]
#+latex_header:\usepackage{braket}
#+latex_header_extra:\institute[Mannodi Group]{\large{}
#+latex_header_extra:\inst{1} Purdue Materials Engineering\\Advisor Arun Mannodi-Kanakkithodi
#+latex_header_extra:}
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex
#+date: \today
#+setupfile: ~/org/beamer_header.org
#+PROPERTY: header-args:jupyter-python :session mrg :kernel mrg :pandoc org :async yes
#+PROPERTY: header-args :results scalar drawer :eval never-export :exports results
* COMMENT dependencies
#+INCLUDE: /home/panos/Documents/manuscripts/DFT+ML+feature_engineering/dependencies.org
#+begin_src jupyter-python
  import datetime
  import io
#+end_src

#+RESULTS:
:results:
:end:

* COMMENT setup codes
#+begin_src jupyter-python
  class QEParser():
      def __init__(self, filepath):
          """
          Parse Quantum Espresso Electronic Structure Output files.

          instantiate QEParser with a path to a QE output file

          call get_df method to return a long dataframe
          """
          with open(filepath) as f:
              lines = f.readlines()
          self.dstrings = "".join(lines)
          self.nameblock = re.compile(r"[-.]+\n [A-Za-z0-9\.\s\(#\)-]+[-.]+")

      def string_pop(self, string, delimiter):
          """ strings are immutable,
          so this reassigns dstring after splitting """
          datalist = string.split(delimiter)
          data = datalist.pop(0)
          self.dstrings = "".join(datalist)
          return data

      def get_df(self):
          """produce dataframe from init file"""
          nameblocks = re.findall(self.nameblock, self.dstrings)
          names = list(map(lambda s: s.split("\n")[1:-1], nameblocks))
          dfs=[]
          self.dstrings = self.dstrings.replace(nameblocks.pop(0),"")
          for block,name in zip(nameblocks, names):
              dstring = self.string_pop(self.dstrings, block)
              name="\n".join(name).replace(" ", "_").replace("_", "", 1)
              sio = io.StringIO(dstring, newline='\n')
              dfs.append(
                  pd.read_csv(
                      sio, header=0, on_bad_lines='warn'
                  ).assign(name=name)
              )
              sio = io.StringIO(self.dstrings, newline='\n')
          name="\n".join(names[-1]).replace(" ", "_").replace("_", "", 1)
          dfs.append(
              pd.read_csv(
                  sio, header=0, on_bad_lines='warn'
              ).assign(name=name)
          )
          return pd.concat(dfs, axis=0)
#+end_src

#+RESULTS:
:results:
:end:

* COMMENT load sample and spaces
#+begin_src jupyter-python
  Xt = pd.read_csv("./X_t.csv", index_col=0)
  Xc = pd.read_csv("./X_c.csv", index_col=0)
  Xp = pd.read_csv("./X_p.csv", index_col=0)
  X = Xt
  Y = pd.read_csv("./Y.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  X_big = pd.read_csv("./X_card.csv", index_col=0)
  Y_big = pd.read_csv("./Y_card.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  XX = pd.read_csv("./X_processed.csv", index_col=0)
  XX_big = pd.read_csv("./X_card_processed.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

* Devices and Perovskites Background
# Introduce PVs
# - the band gap controls the lowest energy photon that can be absorbed
# - perovskites demonstrate good transport
# establish recent context
# - advancements
# - other applications
# what perovskites are and why you should care
# 1. familiar BaTiO3
# 2. halide perovskites
# Combinatorial Mixing in-depth Discussion
# - discuss properties which contribute to this performance
# - why we need computational methods
** DONE Photovoltaic (PV) Power Generation                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-22 Mon 16:19]
:END:
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+attr_latex: :width 90
[[file:thin-film-PV.png]]
#+attr_latex: :width 90
[[file:Si-HaP-tandem-PV.png]]

\tiny{}\center{}Perovskite Applications[fn:2]

**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
***** Band Gap (bg) Effects on Absorption Spectrum              :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
****** col                                                       :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src jupyter-python
  df = QEParser('/home/panos/Documents/masters/GaN_ZB_AS.txt').get_df()
#+end_src

#+begin_src jupyter-python :post wrap(*this*, w="130pt")
  p0 = make_subplots(rows=2, cols=1, shared_xaxes=True)

  p1 = px.line(df, x='Wavelength (nm)', y=' Absorption Coefficient', color='name',
              height=200, width = 400,)

  p0.add_trace(p1.data[0], row=1, col=1)
  colorsteps = 750
  p0.add_trace(go.Bar(
      y=['spectrum']*colorsteps,
      x=[1]*colorsteps,
      orientation='h',
      marker=dict(
          color=list(range(colorsteps)),
          colorscale='Rainbow',
          cmin=103,
          cmax=750,
          showscale=False
      )
  ), row=2, col=1)

  p0.update_xaxes(range=[103, 750], tickfont_size=30)
  p0.update_xaxes(title='wavelength [nm]', row=2, col=1, title_font_size=30)
  p0.update_yaxes(visible=False, row=2, col=1)
  p0.update_yaxes(title='alpha', row=1, col=1, title_font_size=30, tickfont_size=30)

  p0.add_vline(x=628.019, annotation_text='628 nm', annotation_font_size=40,
               line_color='black', line_width=2, row=1, col=1)
  p0.update_layout(
      showlegend=False,
      margin=dict(t=0,b=0,l=0,r=0),
      yaxis_domain = [0.1, 1.0], yaxis2_domain = [0.0, 0.1]
  )
  p0.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 130pt
[[file:./.ob-jupyter/e44c0e6b821bb2eea4fc6ed321c93e99352b8192.svg]]
:end:

****** col                                                       :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

\begin{align*}
E_\gamma = \hbar\omega &= bg\,\si{\joule} \\
\implies \frac{hc}{628\,\si{\nano\meter}} &= 3.16\times{}10^{-19}\,\si{\joule}\\
&= 1.97\,\si{\electronvolt}
\end{align*}

***** Perovskite Semiconductors in Solar Energy Harvesting      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- 2009 : \(\ce{MAPbI_3}\) dye-sensitized absorber with 3.8% PCE
  [cite:@kojima-2009-organ-halid]
- 2011 : absorber efficiency doubles
  [cite:@im-2011]
- 2013 : \(\ce{MAPbX_3}\) found to transport holes+electrons
  [cite:@saliba-2014-influen-therm]

# HaP PVs become competitive in 2013
** DONE Rapid Rise of Perovskite Photovoltaics                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"       [2023-06-07 Wed 11:15]
- State "NEXT"       from              [2023-05-22 Mon 17:08]
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:

#+DOWNLOADED: screenshot @ 2023-05-15 18:16:32
#+attr_latex: :width 250pt
[[file:Perovskites/2023-05-15_18-16-32_screenshot.png]]

*** COMMENT col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src jupyter-python
  history = pd.read_csv('~/data/perovskites/NREL-pvcell-efficiency.csv', index_col=0)
  x = "Measurement Date"
  y = "Combined efficiency (%)"

  history[x] = history[x].apply(lambda x: datetime.datetime.strptime(x, '%m/%d/%Y'))
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(w="280pt")
  color_map = {
      ('Crystalline Si Cells', 'Single crystal (non-concentrator)'): px.colors.qualitative.Plotly[0],
      ('Emerging PV', 'Perovskite cells'): px.colors.qualitative.Plotly[1],
      ('Single-Junction GaAs', 'Single crystal'): px.colors.qualitative.Plotly[0],
      ('Emerging PV', 'Perovskite/Si tandem (monolithic)'): px.colors.qualitative.Plotly[1],
      ('Thin-Film Technologies', 'CdTe'): px.colors.qualitative.Plotly[2],
  }

  traces = []
  for (cat1, cat2), g in history.groupby(
      ["Eff. Chart Material Class", "Eff. Chart Cell Type"]
  ):
      if (cat1, cat2) in color_map.keys():
          best = g.groupby(x).max(y)[y].cummax()
          trace = go.Scatter(
              x=best.index,
              y=best,
              name=f'{cat1}-{cat2}',
              line_color=color_map[(cat1, cat2)],
              mode='lines+markers'
          )
          traces.append(trace)

  # Create the layout
  layout = go.Layout(
      xaxis_title=x, yaxis_title=y,
      legend=dict(orientation="h", y=1.1)
  )

  p = go.Figure(data=traces, layout=layout)
  p.update_xaxes(
      minor=dict(ticks="inside", showgrid=True)
  )
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 280pt
[[file:./.ob-jupyter/5a70cef7f43718d2462f4328daceef604482623e.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- Cumulative maximum efficiency of PVs tested by accredited laboratories
  [cite:@research-2023-best-resear]
- Perovskite+Si tandem monolithic cells second only to two-junction \(\ce{GaAs}\)
- Other rising applications
  - LEDs and photodiodes
  - infrared sensors
  - superconductors
  - quantum bits

** DONE COMMENT What's a Perovskite?                                       :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-22 Mon 17:08]
:END:
# relaxor : character w/ highly nonlinear dielectric constant and
# diffused ferroelectric to para electric phase transition (no well
# defined Curie temperature)
*** Oxide Perovskites                                     :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Notable oxide perovskites and properties circa 2006
[cite:@jiang-2006-predic-lattic]
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
\small
| <K,Ba>BiO3  | super-conduction      |
| Pb<Zr,Ti>O3 | piezoelectric action  |
| Pb<Mb,Mg>O3 | relaxor ferroelectric |
| BaTiO3      | dielectric properties |
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
\small
| Pb<Zr,Ti>O3 | electro-optic         |
| LaMnO3      | magneto-resistance    |
| LaCrO3      | catalytic             |
| BaCeO3      | photonic conductivity |
*** fig                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+DOWNLOADED: screenshot @ 2022-07-14 15:32:57
#+CAPTION: Barium Titanate functional ceramic
#+attr_latex: :width 170
[[file:Introduction_To_Perovskites/2022-07-14_15-32-57_screenshot.png]]

** DONE Halide Perovskites                                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-23 Tue 10:45]
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
- purely inorganic (e.g., CsPbI3)
- hybrid organic-inorganic (e.g., MAPbBr3)
  - MA :: methylammonium \(\ce{CH3NH3+}\)
  - FA :: formamidium \(\ce{CH(NH2)2+}\)
- tailor stability and electronic/optical properties of \(\ce{ABX3}\)
  compounds by changing
  - component at each site
  - mix of components
  - atom arrangement
# structure, octahedral arrangements, point defects, interfaces, etc.

#+caption: \(\ce{ABX3}\) Site Candidates
| /      | <  |    |    |    |    |    |
| A-site | MA | FA | Cs | Rb | K  |    |
| B-site | Pb | Sn | Ge | Ba | Sr | Ca |
| X-site | I  | Br | Cl |    |    |    |

*** COMMENT col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+DOWNLOADED: screenshot @ 2022-07-15 23:57:31
#+attr_latex: :width 115
[[file:Introduction_To_Perovskites/2022-07-15_23-57-31_screenshot.png]]
Perovskite Solar Absorber Layer[fn:1]
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+attr_latex: :width 140
[[file:hybrid-HaP.png]]

\center{}2x2x2 \alpha-phase supercell\break *with MA at A-site*

** DONE Perovskite Formability                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-05-25 Thu 16:16]
:END:
- A must be much larger than B for Perovskite formation
- Various tolerance factors have been designed to describe this constraint
- B usually large (e.g. Pb, Sn) in Halide Perovskites
- A accommodates *molecules* with large effective ionic radii[cite:@kieslich-2015-exten-toler]

The following definitions approximate \alpha phase stability
[cite:@yin-2015-halid-perov;@bartel-2019-new-toler]
*** Goldschmidt Tolerance                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.33
:END:

\[
t = \frac{R_A+R_X}{\sqrt{2}*(R_B+R_X)}
\]

\[
0.813 < t < 1.107
\]

*** Octahedral Factor                                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.33
:END:

\[
o=\frac{r_B}{r_X}
\]

\[
0.442 < o < 0.895
\]

*** Bartel Tolerance                                        :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.33
:END:

\[
\tau = \frac{r_X}{r_B}-\left[ 1-\frac{\frac{r_A}{r_B}}{ln(\frac{r_A}{r_B})} \right]
\]

\[
\tau < 4.18
\]

** DONE Spectroscopic Limited Maximum Efficiency (SLME)            :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-03 Sat 17:00]
:END:
SLME accounts for more energetic processes than Shockley-Queisser
criterion (\(bg \approx 1.3\)) allowing selection on range of bandgaps
determined according to level of theory[cite:@yu-2012-ident-poten p.1]

\[
a(E)=1-e^{-2\alpha(E)L}
\]

Here, \(\alpha(E)\) is the simulated optical absorption coefficient
as a function of incident photon energy and \(L\) is the thickness of
the absorber.

\[
J=e\int_{0}^{\infty} a(E)I_{sun}(E)dE - J_{0}(1-e^{\frac{eV}{kT}})
\]

\[
\eta = \frac{P_{m}}{P_{in}}=\frac{\max(J \times V)}{P_{in}}
\]

To calculate SLME efficiency the current density \(J\), the light
spectrum intensity of sunlight \(I_{sun}\), and the power \(P\) are
all that is needed.

** DONE Absorbance Relates to Efficiency via Band Gap in Our Data  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-26 Fri 15:21]
:END:
#+begin_src jupyter-python :post wrap(*this*, w="370pt")
  p0 = make_subplots(rows=1, cols=2, shared_yaxes=True)

  p1 = px.scatter(
      Y[Y.LoT == "EXP"], x="bg_eV", y="efficiency", color="mix",
  )
  p2 = px.scatter(
      Y[Y.LoT == "PBE"], x="bg_eV", y="efficiency", color="mix",
  )

  for trace1, trace2 in zip(p1.data, p2.data):
      p0.add_trace(trace1, row=1, col=1)
      p0.add_trace(trace2, row=1, col=2)

  p0.update_xaxes(
      range=(0, 4), title="Band Gap [eV]",
      tickfont_size=20
  )
  p0.update_yaxes(
      tickfont_size=20
  )
  p0.update_yaxes(row=1, col=1,
                 title="Power Conversion Efficiency",
                 )
  p0.update_yaxes(row=1, col=2,
                 title="SLME for PBE<br>Absorption Spectra",
                 )

  h_lin1 = go.layout.Shape(type='line',
                           x0=1.0, y0=0.0,
                           x1=1.0, y1=0.25,
                           line=dict(color='black', width=2))
  h_lin2 = go.layout.Shape(type='line',
                           x0=2.0, y0=0.0,
                           x1=2.0, y1=0.25,
                           line=dict(color='black', width=2))
  v_line = go.layout.Shape(type='line',
                           x0=0.0, y0=0.15,
                           x1=4.0, y1=0.15,
                           line=dict(color='black', width=2))
  rect = go.layout.Shape(type='rect', #line=dict(color='blue', width=2)
                         x0=1.0, y0=0.15,
                         x1=2.0, y1=0.25,
                         fillcolor='blue', opacity=0.2)
  p0.add_shape(h_lin1, row=1, col=2)
  p0.add_shape(h_lin2, row=1, col=2)
  p0.add_shape(v_line, row=1, col=2)
  p0.add_shape(rect, row=1, col=2)

  p0.update_layout(
      margin=dict(t=0,b=0,l=0,r=0),
      showlegend=False,
      width=800, height=300
  )

  p0.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 370pt
[[file:./.ob-jupyter/64174f234626288aaaca8eb9d0ba24f1cfdbe000.svg]]
:end:

Inform screening criterion reported by these results[cite:@yang-2023-high-throug] 
- SLME used as computational proxy for PCE
- Experimental data[cite:@almora-2020-devic-perfor] broadly agrees with PBE simulation

** DONE My Thesis Research Overview                                :B_frame:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-03 Sat 14:10]
:END:
The work we did in [cite/title:@yang-2023-high-throug][cite:@yang-2023-high-throug]
- created the multi-fidelity dataset covering the chemical domain
- decided the screening criterion used to judge viability of compositions

#+caption: \(\ce{ABX3}\) Site Candidates
| /      | <  |    |    |    |    |    |
| A-site | MA | FA | Cs | Rb | K  |    |
| B-site | Pb | Sn | Ge | Ba | Sr | Ca |
| X-site | I  | Br | Cl |    |    |    |

The work I did in [cite/title:@manganaris-2023-multi-fidel][cite:@manganaris-2023-multi-fidel]
- methods for predicting band gaps at experimental fidelity
  - open-source tools developed for this work
  - made available to the broader materials science community
- use predictions + screening to search sample space for promising compounds

# show what mixing at A B X means!!

** DONE Design Goals in *14-Dimensional* Composition Space         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-05-23 Tue 18:43]
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
**** Deficiencies in Leading Perovskite PVs                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
inherent instability/short life-cycle
- degradation in sunlight
- soluble in water
environmental impact
- toxicity of Lead (Pb)

**** fig all components                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+begin_src jupyter-python :post wrap(*this*, w="150pt :options inkscapeformat=png, inkscapedpi=300")
  p = px.sunburst(XX_big.iloc[:,1:14].replace(0,np.NaN)
                    .join(Y_big[['mix']])
                    .groupby(['mix'])
                    .sum().reset_index().melt(id_vars=['mix']),
                  path=['variable'], values='value')
  p.update_traces(insidetextorientation='horizontal',
                  textinfo="label+percent parent")

  p.update_layout(
      margin=dict(l=0, r=0, t=0, b=0),
      font_size=30
  )
  llist = p.data[0].labels
  p.data[0].labels = [re.sub("comp__|['\(\),)]", "", l) for l in llist]
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 150pt :options inkscapeformat=png, inkscapedpi=300
[[file:./.ob-jupyter/7b552d6e27bb59ea631cff90bf7278de09b04ca3.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
**** fig mixing                                          :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+begin_src jupyter-python :post wrap(*this*, w="150pt :options inkscapeformat=png, inkscapedpi=300")
    p = px.sunburst(Y_big, path=['mix'])
    p.update_layout(
        margin=dict(l=0, r=0, t=0, b=0),
        font_size=60
    )
    p.update_traces(insidetextorientation='horizontal',
                    textinfo="label+value")
    llist = p.data[0].labels
    p.data[0].labels = [l + '-site mixed' for l in llist]
    p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 150pt :options inkscapeformat=png, inkscapedpi=300
[[file:./.ob-jupyter/4a7937400ef9f31b84cb014534685b0ec1de85c5.svg]]
:end:

**** Search for Improved Compounds                               :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:

*37,785* out of *207+ million* compounds possible in a 2x2x2 supercell
will be examined for solutions to these deficiencies using
- high-throughput density functional theory
- data collected from literature
- multi-fidelity machine learning

** COMMENT Attractive Properties of Perovskites                            :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+DOWNLOADED: screenshot @ 2022-07-16 01:34:42
#+attr_latex: :width 200
[[file:Introduction_To_Perovskites/2022-07-16_01-34-42_screenshot.png]]
Typical severity of gap states
[cite:@mannodi-kanakkithodi-2020-defec-energ]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- robust against carrier scattering
  [cite:@yan-2016-defec-physic]
- spontaneously forming high energy defects unlikely
- edge-states
- finite internal dipole moments
  [cite:@hong-2021-layer-edge]
  - ferroellectrically aligned ligands
  - long luminescence lifetimes
- hydro-stability
  [cite:@fu-2021-two-dimen]
  - hydrophobic ligands

** COMMENT Hybrid Organic-Inorganic Perovskites                            :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+DOWNLOADED: screenshot @ 2022-07-18 13:42:36
#+attr_latex: :height 90
#+attr_org: :width 90
[[file:Introduction_To_Perovskites/2022-07-18_13-42-36_screenshot.png]]

\(\alpha\)-Phase \(Pm\bar{3}m\) Hybrid Perovskite Crystal
[cite:@yan-2016-defec-physic]

\(\ce{ABX3}\) with \(\ce{A=CH3NH3+}\) (MA)
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+DOWNLOADED: screenshot @ 2022-07-13 19:55:58
#+attr_latex: :height 90 :options angle=90
#+attr_org: :width 90
[[file:Introduction_To_Perovskites/2022-07-13_19-55-58_screenshot.png]]
2-D Ruddlesden-Popper \(Pbca\) Hybrid Perovskite Crystal
[cite:@hong-2021-layer-edge]

\(\ce{L_2BX_4}\) with \(\ce{L=C4H12N+}\) (BA)

Generalizes to LA_{m-1}B_{m}X_{3m+1} perovskite with m>1

* Computational Methods In Materials Science
# discuss DDMD in group context + introduce DFT and ML
# discuss DFT in general -- distance myself from data
# - why dft? uses quantum mechanics -- still expensive big integral
# be prepared to discuss functionals
# combinatorially scaling chemical space
# bandgaps are unpredictably deviating away from Vegard's law.
# mention ongoing work on inverse design lead by Arun

** Density Functional Theory and Simulation Fidelities             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
Vienna /ab initio/ Simulation Program (VASP)[cite:@kresse-1996-effic-iterat] computes
1. ground state atomic structure of perovskite
2. energy levels and occupation of crystal structure's orbitals

*** Find Ground State Energy using Levels of Theory (LoT)         :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:

\[
\min_n(E(n)) = \min_n(\hat{T}(n) + \hat{U}(n) + \hat{V}(n))
\]

\(\hat{U}(n)\) approximations account for varying levels of quantum theory 

- Perdew-Burke-Erzenhof (PBE) :: modern Generalized Gradient Approximation
- Heyd-Scuzeria-Erzenhof (HSE) :: hybrid GGA and Hartree-Folk Theory
- HSE with Spin Orbit Coupling :: corrects for electronic effect of heavy elements (e.g. \(\ce{Pb}\))
- HSE(SOC) on PBE relaxed structure :: compromise, using PBE only for structure relaxation

Spin Orbit Coupling (SOC) Accounts for relativistic effects near heavy nuclei

** DFT Calculation of Perovskite Band Gaps in Literature           :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+DOWNLOADED: screenshot @ 2023-05-24 05:33:49
[[file:Computational_Methods_In_Materials_Science/2023-05-24_05-33-49_screenshot.png]]

HSE06 improves band gap predictions compared to PBE[cite:@chan-2010-effic-band]

** Machine Learning for Property Prediction                        :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+DOWNLOADED: screenshot @ 2023-05-24 04:42:21
#+attr_latex: :width 300
[[file:Computational_Methods_In_Materials_Science/2023-05-24_04-42-21_screenshot.png]]

*** Applications in Materials Science                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Algorithms improving with exposure to data.
[cite:@pablo-2019-new-front]

Given enough data
- predict properties
- classify materials broadly
- predict interatomic force fields without solving physics equations

** DONE Data Driven Framework for Perovskite Discovery             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 04:30]
:END:
#+attr_latex: :width 390
#+attr_org: :width 90
[[file:DDD-flowchart.png]]
\center{}\vspace{-0.75cm}Workflow for accelerating development of new PV materials
[cite:@yang-2023-high-throug]
via ongoing inverse design work
[cite:@yang-2023-discov-novel]

** COMMENT Motives for Alternative Features                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** Plan of Investigation                                         :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
1. relate various bulk properties of molecules to performance of
   existing perovskite solar absorbers
2. extrapolate into the unknown
*** Known Organic Constituents currently in use                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Literature provides examples of known performant ligands:
- Methylammonium (Cationic Methylamine)
  [cite:@yan-2016-defec-physic]
- Formamidinium (Cationic Formamidine)
  [cite:@dimesso-2016-inves-formam]
- Guanidinium (Cationic Guanidine)
  [cite:@zhang-2019-perov-photov]
- Butylammonium (Cationic Butylamine)
  [cite:@hong-2021-layer-edge]

* Perovskites Band Gaps Data and Descriptors  
# model bg because 
# - bg models are more generally useful than SLME
# - SLME is more expensive to compute

# rationalize the use of various features in models
# explain the features vectors, illustrate them graphically somehow
# codomain side
# - choose to model perovskite band gaps per SQ criterion
# domain side
# - various empirical tolerance factors used in screening
# - discuss use of Electronegativity, etc, etc
# pearson plots solidify the vector concept
# - Show Correlations with each LoT!
** COMMENT compute distributions
#+begin_src jupyter-python
  dist = XX.loc[~X.LoT.isin(['EXP'])].iloc[:, 0:14].replace(
      0, np.NaN
  ).melt().dropna()

  dist[['site', 'Element']] = dist['variable'].str.replace(
      r"[\(\)']", "", regex=True
  ).str.split(
      ",", 1, expand=True
  )
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  def make_percent(df):
      df = df.assign(variable = df.variable / df.variable.sum() * 100)
      return df
#+end_src

#+RESULTS:
:results:
:end:
** DONE Sample of 14-Dimensional Composition Space                 :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-03 Sat 15:42]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- 500 unique compositions
- 5 measurement fidelities
- 1300 simulated band gaps
- 90 experimentally measured band gaps
  
#+begin_src jupyter-python :post wrap(*this*, w="200pt")
  p = px.sunburst(Y, path=['LoT','mix'])
  p.update_layout(
      margin=dict(l=0, r=0, t=0, b=0),
      font_size=60
  )
  p.update_traces(insidetextorientation='horizontal',
                  textinfo="label+value")
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 200pt
[[file:./.ob-jupyter/90faa4a4ad85bb6db363729920bb2c449385e86c.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src jupyter-python :post wrap(*this*, w="190pt")
  freq = dist.groupby(['value', 'site', 'Element']).count().reset_index().sort_values('site')

  p = make_subplots(cols=2, rows=2,
                    subplot_titles=("A-site", None, "B-site", "X-site"),
                    shared_xaxes=True,
                    y_title="Element Frequency (%)",
                    vertical_spacing=0.15)

  elnum = {'A': 5, 'B': 6, 'X': 3}
  rowdict = {0:1, 1:2, 2:2}
  coldict = {0:1, 1:1, 2:2}

  for i, g in enumerate(freq.site.unique()):
      group = freq[freq.site == g].pipe(make_percent)
      colors = dict(zip(group['Element'].unique(), px.colors.qualitative.Plotly))
      traces = []
      for count, (element, sub) in enumerate(group.groupby('Element')):
          color_map = colors[element]
          traces.append(
              go.Bar(
                  x=sub['value'], y=sub['variable'], marker=dict(color=color_map),
                  name=element,
                  legendgroup=g, legendgrouptitle_text=g[-1]+'-site',
                  width=0.02, offsetgroup=count
              )
          )
      for trace in traces:
          p.add_trace(trace, col=coldict[i], row=rowdict[i])

      p.update_xaxes(
          title='Share of ' + g[-1] + ' Site',
          title_font_size=30,
          tickfont_size=24,
          tickmode='array',
          tickvals=np.linspace(0,1,9),
          ticktext=[f'{f.as_integer_ratio()[0]}/{f.as_integer_ratio()[1]}' for f in np.linspace(0,1,9)],
          col=coldict[i], row=rowdict[i]
      )
      p.update_yaxes(col=coldict[i], row=rowdict[i],
                     tickfont_size=24,)


  p.for_each_annotation(lambda a: a.update(font_size=30))

  p.update_layout(
      legend=dict(
          bgcolor='rgba(0,0,0,0)',
          orientation="h",
          xanchor='center',
          y=1.0, x=0.77,
          itemsizing='constant',
          font_size=20
      ),

      margin=dict(t=40,b=0,l=70,r=0),
      width=600, height=700
  )
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 190pt
[[file:./.ob-jupyter/95b93277e9406ce0d36f9f13562ea1f865cc5ead.svg]]
:end:

** DONE Collecting Data is Hard                                    :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-03 Sat 08:37]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
experiments take years to perform and much labor to organize
[cite:@almora-2020-devic-perfor]

#+DOWNLOADED: screenshot @ 2023-05-24 08:01:24
#+attr_latex: :width 190
[[file:Data/2023-05-24_08-01-24_screenshot.png]]

\vspace{-0.5cm}DFT calculations take multiple
- hours to converge at PBE level
- days to converge at HSE level
- days more to debug
Years of work by Professor Arun and Jiaqi have generated
the largest cubic HaP computational database.[cite:@yang-2023-high-throug]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+begin_src jupyter-python :post wrap(*this*, w="120pt")
    p = px.box(Y, y="bg_eV", x="LoT",
               width=400, height=700)
    p.update_xaxes(title_font_size=24, tickfont_size=30,
                   tickangle=-35, title=None)
    p.update_yaxes(title="Band Gap [eV]", title_font_size=30,
                   tickfont_size=30)
    p.show('svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 120pt
#+attr_org: :width 640
[[file:./.ob-jupyter/3822d7499fa7752e34ad5c4f42ca00509c26cbc3.svg]]
:end:

** Effect of DFT Functionals on Our Perovskites Data               :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+begin_src jupyter-python
  lot_compared = Y.groupby(
      "Formula", as_index=False
  ).apply(
      lambda df: df[["Formula", "bg_eV", "LoT"]].set_index(["Formula", "LoT"]).unstack("LoT")
  ).dropna(how="any", axis=0)
  lot_compared.index = lot_compared.index.droplevel(0)
  lot_compared.columns = lot_compared.columns.droplevel(0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*, w="400pt")
   df = lot_compared.reset_index().melt(id_vars="Formula")
   p = px.scatter(df, y="value", x="Formula", color="LoT")
   p.update_yaxes(title="Band Gap [eV]")
   p.update_xaxes(title="", tickangle=-30)
   p.update_layout(width = 600, height = 300,
                   margin=dict(t=0,b=0,l=0,r=0),
                   legend=dict(orientation='h', y=-0.4,
                               itemsizing='constant'))
   p.add_annotation(x=3, y=3.3, xref='x', yref='y',
                    text="RMSE v. EXP<br>PBE = 0.55<br>HSE = 0.87<br>HSE(SOC) = 0.61<br>HSE-PBErel(SOC) = 0.44",
                    font_size=15,
                    showarrow=False)
   p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 400pt
[[file:./.ob-jupyter/618bfd7f0900f6415f0a4a0a8c242c95ccd16e7e.svg]]
:end:

** Describing a Halide Perovskite                                  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** COMMENT compute pearson
#+begin_src jupyter-python
  lot_compared = Y.groupby(
      "Formula", as_index=False
  ).apply(
      lambda df: df[["Formula", "bg_eV", "LoT"]].set_index(["Formula", "LoT"]).unstack("LoT")
  )
  lot_compared.index = lot_compared.index.droplevel(0)
  lot_compared.columns = lot_compared.columns.droplevel(0)
  lot_compared = lot_compared.reset_index()
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  formX = pd.concat([Y.Formula, XX], axis=1)# .reindex(index=lot_compared.index)
  df = pd.merge(left=lot_compared, right=formX, how='left', on='Formula').set_index(
      [c for c in formX.columns if not c in formX.select_dtypes(np.number).columns]
  )
#+end_src

#+RESULTS:
:results:
:end:
  
#+begin_src jupyter-python
  pearson = pd.DataFrame(np.corrcoef(df.fillna(0), rowvar=False),
                         columns=df.columns,
                         index=df.columns)
#+end_src

#+RESULTS:
:results:
:end:

*** 14 Dimensional Chemical Vector                          :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.45
:END:
#+begin_src jupyter-python :post wrap(*this*, "195pt")
  sub = pearson.iloc[0:5, 5:19]
  p = px.imshow(sub, color_continuous_scale='RdBu_r', zmin=-1, zmax=1,
                labels=dict(color="Pearson Coefficient"),
                # text_auto='.2f'
                )
  p.update_xaxes(tickangle=-40, tickfont_size = 30,
                 tickmode='array',
                 tickvals=list(range(sub.columns.shape[0])),
                 ticktext=sub.columns.str.slice(6).str.replace("'", "").str.replace("_"," ")
                 )
  p.update_yaxes(tickangle=-40, tickfont_size = 30,
                 tickmode = 'array',
                 tickvals=list(range(sub.index.shape[0])),
                 ticktext=[l + " bg" for l in sub.index.to_list()]
                 )
  p.update_layout(
      coloraxis=dict(colorbar=dict(len=1, orientation='h', y=0.8)),
      margin=dict(t=0,b=0,l=0,r=0),
      font_size=20,
      # paper_bgcolor='rgba(255,255,255,0)',
      # plot_bgcolor='rgba(255,255,255,0)',
  )
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 195pt
[[file:./.ob-jupyter/9243bcb2031c7328e1ba637cc61904eaacaec02d.svg]]
:end:

*** Parsing compositions using =cmcl=                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.55
:END:
#+begin_src jupyter-python :exports src
  import cmcl
  Y = load_codomain_subset()
  df = Y.Formula.to_frame().ft.comp()
  df.index = Y.Formula
  print(df)
#+end_src

\begin{small}
\begin{verbatim}
                    FA   Pb   Sn    I   MA   Br
Formula                                        
FAPb_0.7Sn_0.3I_3  1.0  0.7  0.3  3.0  NaN  NaN
MAPb(I0.9Br0.1)3   NaN  1.0  NaN  2.7  1.0  0.3
\end{verbatim}
\end{small}

** 40000 Composition Vectors projected to 2D                       :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
*** COMMENT load projection
#+begin_src jupyter-python
  projdf = pd.read_csv("./proj_t_rfr_tsne_c.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- t-SNE projection projects 14D composition vectors to 2D
- forms clusters of similar points
- ~500 compositions sampled by our research group
  [cite:@yang-2023-high-throug]
- ~90 compositions sampled in the literature
  [cite:@almora-2020-devic-perfor]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src jupyter-python :post wrap(*this*, w="200pt")
  p = px.scatter(
      projdf.replace(np.NaN, False),
      facet_col='perplexity', facet_col_wrap=4,
      x='0', y='1',
      hover_name="Formula",
      color='LoT'
  )
  p.update_layout(
      legend_title="Sampled", legend_itemsizing='constant',
      legend_orientation='h', legend_y=0.05,
      margin=dict(l=0, r=0, t=0, b=0),
      width=400, height=400
  )
  p.update_yaxes(matches=None, visible=False)
  p.update_xaxes(matches=None, visible=False)

  p.data[0].name='SIM'

  p.data = (p.data[1], p.data[0], p.data[2])

  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 200pt
#+attr_org: :width 640
[[file:./.ob-jupyter/af817dadfec86424566f849862ac137f443e9223.svg]]
:end:

** Constituent Properties                                          :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** Twelve Properties per \(\ce{ABX_3}\) constituent              :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Ionic Radius
- Boiling Temperature
- Melting Temperature
- Density
- Atomic Weight
- Electron Affinity
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Ionization Energy
- Heat of Fusion
- Heat of Vaporization
- Electronegativity
- Atomic Number
- Period

*** non                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
compute by averaging elemental properties obtained from Mendeleev database
[cite:@mentel-2014]
weighted by stoichiometry of elements at A/B/X-site.

** DONE Correlating Band Gap with 36 Dimensional Property vector   :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"       [2023-06-03 Sat 12:47]
- State "NEXT"       from "TODO"       [2023-05-26 Fri 18:08]
:END:
# #+DOWNLOADED: screenshot @ 2023-05-19 12:18:44
# #+attr_latex: :width 380
# [[file:Data/2023-05-19_12-18-44_screenshot.png]]

# \vspace{-1cm}
band gap at higher levels of theory correlate with composition differently[cite:@yang-2023-high-throug]

#+begin_src jupyter-python :post wrap(*this*, "390pt")
  sub = pearson.iloc[0:5, 19:55]
  p = px.imshow(sub, color_continuous_scale='RdBu_r', zmin=-1, zmax=1,
                labels=dict(color="Pearson Coefficient"),
                height=400, width=1000, aspect='auto',
                # text_auto='.2f'
                )
  p.update_xaxes(tickangle=-40, # tickfont_size = 30,
                 tickmode='array',
                 tickvals=list(range(sub.columns.shape[0])),
                 ticktext=sub.columns.str.slice(6).str.replace("'", "").str.replace("_"," ")
                 )
  p.update_yaxes(tickangle=-40, # tickfont_size = 30,
                 tickmode = 'array',
                 tickvals=list(range(sub.index.shape[0])),
                 ticktext=[l + " bg" for l in sub.index.to_list()]
                 )
  p.update_layout(coloraxis=dict(colorbar=dict(len=1, orientation='h', y=1)))
  p.update_layout(
      margin=dict(t=0,b=0,l=0,r=0),
      font_size=20
      # paper_bgcolor='rgba(255,255,255,0)',
      # plot_bgcolor='rgba(255,255,255,0)',
  )
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 390pt
[[file:./.ob-jupyter/4aff497f1c6138caa314121c64efb73b46e75d71.svg]]
:end:

* Multi-Fidelity Learning
:LOGBOOK:
- State "NEXT"       from              [2023-05-24 Wed 11:51]
:END:
# challenges of learning from multiple fidelities
# compare to multi-task learning
# the model places more weight on different observations
# - I created yogi! place higher weight on EXP LoT while optimizing hyperparameters
# - oversampling is an alternative
# show uncertainties in GPR posterior over 5 plots
# Bootstrapping is
# show tables -- table showing effect of single-fidelity training, effect of comp or prop exclusive
** DONE Learning from Multi-fidelity dataset                       :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-07 Wed 14:51]
:END:

*** Training Strategy                                             :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- [ ] oversampling
- [X] weight scores on higher fidelities to reward target accuracy
- [-] sequential learning/delta learning
- [-] co-Kriging
# Try Delta learning and Co-Kriging in SI

*** One-Hot Encoding Levels of Theory                             :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:

#+begin_src jupyter-python
  samp = X.LoT.sample(10).reset_index()
  samp
#+end_src

#+RESULTS:
:results:
\scriptsize
| index | LoT             |
|-------+-----------------|
|  1373 | HSE-PBErel(SOC) |
|  1420 | HSE-PBErel(SOC) |
|   887 | EXP             |
|  1361 | HSE-PBErel(SOC) |
|   541 | HSE             |
|   388 | PBE             |
|  1252 | HSE-PBErel(SOC) |
|    89 | PBE             |
|   297 | PBE             |
|   546 | HSE             |
:end:

**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:

#+begin_src jupyter-python
  pd.merge(left=samp, right=XX.iloc[:, -5:].reset_index(), on='index', how='left')
#+end_src

#+RESULTS:
:results:
\scriptsize
| index | EXP | HSE | HSE(SOC) | HSE-PBErel(SOC) | PBE |
|-------+-----+-----+----------+-----------------+-----|
|  1373 |   0 |   0 |        0 |               1 |   0 |
|  1420 |   0 |   0 |        0 |               1 |   0 |
|   887 |   1 |   0 |        0 |               0 |   0 |
|  1361 |   0 |   0 |        0 |               1 |   0 |
|   541 |   0 |   1 |        0 |               0 |   0 |
|   388 |   0 |   0 |        0 |               0 |   1 |
|  1252 |   0 |   0 |        0 |               1 |   0 |
|    89 |   0 |   0 |        0 |               0 |   1 |
|   297 |   0 |   0 |        0 |               0 |   1 |
|   546 |   0 |   1 |        0 |               0 |   0 |
:end:

** COMMENT draft
The challenge: how to best utilize multiple measurements of the
quantity of interest at different fidelities for the same composition

Where \hat{y}_i is a measurement of the unknown true quantity of
interest y_i for a composition X_i, and \epsilon_i is a random
variable for an error term with a probability distribution that
depends on the fidelity of the measurement,

along with all the other parameters of a model f(X_i) for y_i.

Contrast: with single-fidelity data, \epsion_i=\epsilon, a random
variable with a fixed distribution for all measurements

Motivation and intuition:

There is useful information even in low fidelity measurements.  Throw
away nothing.  Help the modeling place more weight on high-fidelity
measurements, less on low-fidelity measurements.  Give the model
additional representational capacity to account for systematic biases
tied to the different fidelities,for the error term, but also the
relationships between y_i and the features of the composition in the
model f(X_i)

** DONE Random Forest Regression (RFR)                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 04:27]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+DOWNLOADED: screenshot @ 2023-05-23 20:23:36
#+attr_latex: :width 260
[[file:Computational_Methods_In_Materials_Science/2023-05-23_20-23-36_screenshot.png]]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
Decision Tree algorithm memorizes an algorithmic path to the target
- trees capture interactions between features
- trees are flexible and may be highly biased to data
The forest of random trees averages many paths
- forest explains variance in data
- forest reduces the variance of error

** DONE Gaussian Process Regression (GPR)                          :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 04:27]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
Informally, GPRs "remember" the training examples and judge unlabeled
data by its similarity to that aggregate memory.
**** Kernel Method                                               :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
the similarity function \(k(x, x')\)
- defines a "universe" of functions
- defines a density of functions prior to any data
- works for any two quantifiably similar \(x\)
  - vectors, text, graphs, etc.

**** Drawbacks                                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- \(\mathcal{O}(N^3)\) training time complexity
- kernels require engineering to accommodate prior expectations
- break down in sparse spaces/high-dimensional spaces

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
# down arrow through bayes rule??
**** COMMENT functions illustration
#+begin_src jupyter-python
    from sklearn.gaussian_process import kernels as K
    from sklearn.gaussian_process import GaussianProcessRegressor
    kerns = [
        K.DotProduct(),      
        1.0 * K.RBF(length_scale=1.0, length_scale_bounds=(1e-1, 10.0))
    ]
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  def plot_density_samples(gpr_model, n_sample):
      x = np.linspace(0, 5, 100)
      x = x.reshape(-1, 1)
      y_mean, y_std = gpr_model.predict(x, return_std=True)
      y = gpr_model.sample_y(x, n_sample)
      df = pd.DataFrame(np.c_[x, y]).set_index(0)
      p = px.line(df)
      p.add_scatter(x=x.reshape(-1), y=y_mean,
                    mode='lines', line_width=5,
                    line_color='black', name='ridge')
      return p
#+end_src

#+RESULTS:
:results:
:end:

**** Sample Prior Functions                                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :post wrap(*this*, w="170pt")
  gpr = GaussianProcessRegressor(kernel=kerns[1], random_state=None)

  p = plot_density_samples(gpr, 5)
  p.update_layout(showlegend=False,
                  margin=dict(l=0, r=0, t=0, b=0),
                  width=400, height=150)
  p.update_xaxes(title="", tickfont_size=20)
  p.update_yaxes(title="", tickfont_size=20)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 170pt
#+attr_org: :width 640
[[file:./.ob-jupyter/ec4d60a2109843449bb674d71a67240d13c1611a.svg]]
:end:

**** Sample Posteriors                                           :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python
  rng = np.random.RandomState(4)
  x_train = rng.uniform(0, 5, 10).reshape(-1, 1)
  y_train = np.sin((x_train[:, 0] - 2.5) ** 2)
  n_samples = 1
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*, w="170pt")
  gpr.fit(x_train, y_train)

  p = plot_density_samples(gpr, 5)
  p.update_layout(showlegend=False,
                  margin=dict(l=0, r=0, t=0, b=0),
                  width=400, height=150)
  p.update_xaxes(title="", tickfont_size=20, range=(0,5))
  p.update_yaxes(title="", tickfont_size=20)

  p.add_scatter(x=x_train.reshape(-1), y=y_train, mode="markers", marker_color='red', marker_size=10)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 170pt
#+attr_org: :width 640
[[file:./.ob-jupyter/eeae18f97963b2846566f847fcd1a8bb5dd88175.svg]]
:end:

** DONE Sure-Independence Screening and Sparsifying Operator (SISSO) :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 05:08]
:END:

Resulting in parsimonious models, e.g. for fatigue strength[cite:@he-2021-learn-inter]
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.45
:END:

- SIS operates on input features creating space of engineered features
- SO creates sparse model
  - rank engineered features by explanatory power
  - pose linear combination from best features
  - solve for coefficients

\begin{align*}
FS = 50.58 &\sqrt{\mbox{Diffusion T} \times (\ce{Cr} + \ce{Ni})}\\
 + 2.24 \ce{C} &|\mbox{Tempering T}\\
 - &|\mbox{Diffusion T} - \mbox{Through-Harden T}||\\
 + 158.71
\end{align*}

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.55
:END:
#+DOWNLOADED: screenshot @ 2022-12-20 09:09:33
#+attr_latex: :width 200
[[file:Computational_Methods_In_Materials_Science/2022-12-20_09-09-33_screenshot.png]]
Notice SIS re-iterations explain the residual[cite:@ghiringhelli-2017-learn-physic]

** Tuning Multi-Fidelity Model Performance by Selecting Hyper-parameters :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+attr_latex: :width 280
[[file:ML_pipe_annot.png]]

*** scores employed                                         :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
HP scoring via =Yogi= tools and SciKit-Learn[cite:@manganaris-2022-mrs-comput].
- (\(R^2\))
- explained variance score
- maximum error score
- RMSE
  - all data points
  - EXP
  - PBE
  - HSE
  - HSE(SOC)
  - HSE-PBErel(SOC)

* Model Training, Testing, and Interpretation
# SLME improves on SQ to give us performant range of band gaps
# - accounts for additional energetic processes
# - dipole-allowed, dipole-forbidden, indirect band gap
# focus on EXP rmse -- I have the ability!
** NEXT Model Training Method                                      :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2023-06-07 Wed 14:52]
:END:
# show test/train split and scoring flowchart
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
1. partition dataset by 80/20 train/test split
   - hold out 282 test set
   - proceed to following steps with 1123 train set
2. instantiate estimator pipeline with default parameters
3. Set up K-folds validation strategy
   1. Generate learning curves with 10-fold validation
   2. Determine adequate size of validation set (the knee)
   3. the K accordingly
4. Perform grid search Hyper-Parameter Optimization (HPO)
   - score on validation set
   - assess scores wholistically to determine best parameters

*** RFR Learning Curves                                     :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:BEAMER_env: block
:END:

#+attr_latex: :width 190pt
[[file:~/Documents/manuscripts/DFT+ML+feature_engineering/RFR/.ob-jupyter/4b5d77be3d415aa5e9faadb59147a7c2f560e136.svg]]

** COMMENT make subplots
*** rfr
#+begin_src jupyter-python
  data = pd.read_csv(os.path.expanduser('~/data/perovskites/rfr_pred.csv'), index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*)
  x='true'
  y='pred'
  p1 = px.scatter(
      data[data.partition=='test'],
      x=x, y=y,
      hover_name="Formula",
      color="LoT"
  )
  xlims = min(data[x]), max(data[y])
  ylims = min(data[y]), max(data[y])
  p1.add_scatter(x = [min(xlims+ylims), max(xlims+ylims)],
                y = [min(xlims+ylims), max(xlims+ylims)],
                mode='lines', name="parity", marker=dict(color="black"),
                row='all', col='all')
  p1.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 300pt
[[file:./.ob-jupyter/8627f511ab579771837323905248dcab187ef0d2.svg]]
:end:

*** gpr
#+begin_src jupyter-python
  data = pd.read_csv(os.path.expanduser('~/data/perovskites/gpr_pred.csv'), index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*)
  x='true'
  y='pred'
  p2 = px.scatter(
      data[data.partition=='test'],
      x=x, y=y,
      hover_name="Formula",
      color="LoT"
  )
  xlims = min(data[x]), max(data[y])
  ylims = min(data[y]), max(data[y])
  p2.add_scatter(x = [min(xlims+ylims), max(xlims+ylims)],
                y = [min(xlims+ylims), max(xlims+ylims)],
                mode='lines', name="parity", marker=dict(color="black"),
                row='all', col='all')
  p2.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 300pt
[[file:./.ob-jupyter/c846ffe7a1311d7c23c3944591435e4c04db8f90.svg]]
:end:

*** sisso
#+begin_src jupyter-python
  data = pd.read_csv(os.path.expanduser('~/data/perovskites/sisso_pred.csv'), index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*)
  x='true'
  y='pred'
  p3 = px.scatter(
      data[data.partition=='test'],
      x=x, y=y,
      hover_name="Formula",
      color="LoT"
  )
  xlims = min(data[x]), max(data[y])
  ylims = min(data[y]), max(data[y])
  p3.add_scatter(x = [min(xlims+ylims), max(xlims+ylims)],
                y = [min(xlims+ylims), max(xlims+ylims)],
                mode='lines', name="parity", marker=dict(color="black"),
                row='all', col='all')
  p3.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 300pt
[[file:./.ob-jupyter/1bbf90fc6004a4cabc25d940f058ea6f7fb3368f.svg]]
:end:

** Test 282 Band Gap Predictions                                   :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+begin_src jupyter-python :post wrap(*this*, w="400pt")
  p0 = make_subplots(rows=1, cols=3, shared_yaxes=True)

  for trace1, trace2, trace3 in zip(p1.data, p2.data, p3.data):
      p0.add_trace(trace1, row=1, col=1) 
      p0.add_trace(trace2, row=1, col=2)
      p0.add_trace(trace3, row=1, col=3)

  p0.update_xaxes(tickvals=list(range(8)))
  p0.update_yaxes(row=1, col=1,
                  title="RFR Prediction",
                  title_font_size=24,
                  tickfont_size=20,
                  )
  p0.update_yaxes(row=1, col=2,
                  title="GPR Prediction", title_standoff=0,
                  title_font_size=24,
                  tickfont_size=20,
                  )
  p0.update_yaxes(row=1, col=3,
                  title="SISSO Prediction", title_standoff=0,
                  title_font_size=24,
                  tickfont_size=20,
                  )
  p0.update_layout(
      width=1500,
      legend= dict(orientation='h', y=-0.3)
  )

  p0.layout.xaxis.scaleanchor="y"
  p0.layout.xaxis2.scaleanchor="y2"
  p0.layout.xaxis3.scaleanchor="y3"

  p0.update_traces(showlegend=False, row=1, col=1)
  p0.update_traces(showlegend=False, row=1, col=2)

  p0.update_xaxes(mirror=True,
                  constrain='domain', title='DFT Calculation',
                  title_font_size=24,)
  p0.update_yaxes(mirror=True)

  p0.update_traces(
      line=dict(color = 'black', width = 4),
  )
  p0.update_traces(
      marker_line=dict(color = 'black', width = 1),
      marker_size=6,
      selector={'marker_symbol':'circle'}
  )

  p0.update_layout(
      margin=dict(t=0, b=0, l=0, r=0),
      width=800, height=330
  )

  p0.add_annotation(x=2.5, y=6, xref='x', yref='y',
                    text="r2 = 0.99<br>maxerr = 0.80<br>rmse = 0.12<br>", font_size=15,
                    showarrow=False)

  p0.add_annotation(x=2.5, y=6, xref='x2', yref='y',
                    text="r2 = 0.98<br>maxerr = 1.28<br>rmse = 0.15<br>", font_size=15,
                    showarrow=False)

  p0.add_annotation(x=2.5, y=6, xref='x3', yref='y',
                    text="r2 = 0.88<br>maxerr = 2.17<br>rmse = 0.47<br>", font_size=15,
                    showarrow=False)

  p0.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 400pt
[[file:./.ob-jupyter/3133b81a112f13e387878a1d018b864f057d9f03.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
Best RFR selected from >30k differently parametrized models

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
Best GPR utilizes non-stationary Matern kernel with \(\nu=3\slash{}2\)

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
Best SISSO model using only 11 features outperforms OLS on 55 features

** Evaluating Models for Use in Screening                          :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
| Score Categories  |  GPR |  RFR | SISSO |
|-------------------+------+------+-------|
| rmse              | 0.15 | 0.12 |  0.47 |
| rmse EXP          | 0.12 | 0.15 |  0.33 |
| rmse PBE          | 0.12 | 0.10 |  0.39 |
| rmse HSE          | 0.21 | 0.15 |  0.51 |
| rmse HSE(SOC)     | 0.15 | 0.10 |  0.57 |
| rmse HSE-PBE(SOC) | 0.13 | 0.13 |  0.47 |

*** Choosing a Model                                        :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:BEAMER_env: block
:END:
- RMSE per fidelity subset at final HPO iteration
- EXP RMSE motivated parameter selection
- EXP RMSE is important
- However, total RMSE is critical indicator of extrapolative ability

GPR outperforms RFR in EXP subset, but RFR shows better extrapolative
ability. RFR is best.
  
** SISSO Expression                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

\begin{align*}
bg\mbox{ [eV]} = 1.752 &((X;\mbox{electronegativity}*A;\mbox{heat of fusion})\\
                       &-(B;\mbox{electron affinity}+B;\mbox{ionization energy}))\\
                -0.586 &((B;Sn-\mbox{HSE})+(\mbox{PBE}-X;\mbox{electronegativity}))\\
                +1.064 &((A;\mbox{electronegativity}-B;Ca)*(B;\mbox{heat of vap}-X;\mbox{electron affinity}))\\
                +4.657
\end{align*}

** Shapely Additive Explanation (SHAP)                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
SHAP values quantify the contribution of a feature \(x_i \in X\) to a prediction
[cite:@lundberg-2017-unified-approac]

#+attr_latex: :width 400
[[file:SHAP-crop.png]]

** SHAP Analyze RFR                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+DOWNLOADED: screenshot @ 2023-05-24 09:40:46
#+attr_latex: :width 350
[[file:Models/2023-05-24_09-40-46_screenshot.png]]

* Discovery of Suitable Compositions
** Make Predictions on *40000* Hypothetical Compounds              :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:

- Make predictions on sample space using RFR
- Predict at experimental data fidelity (LoT = EXP)
- Predictions have expected error of 0.15 eV
- Visualize predictions on t-SNE projection
- No obvious clustering of \(bg \in [1, 2]\,\si{\electronvolt}\)

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src jupyter-python :post wrap(*this*, w="200pt")
  p = px.scatter(
      projdf,
      x='0', y='1',
      hover_name="Formula",
      color="bg_eV",
  )
  p.update_layout(
      coloraxis=dict(colorbar=dict(
          title="band gap [eV]",
          title_side='right',
      )),
      margin=dict(l=0, r=0, t=0, b=0),
      width=500, height=400
  )
  p.update_yaxes(matches=None, visible=False)
  p.update_xaxes(matches=None, visible=False)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 200pt
[[file:./.ob-jupyter/787ace24d92492507b8e898ff8b26e0c00b39084.svg]]
:end:

** Screening Yields                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** COMMENT load screening
#+begin_src jupyter-python
  screen = pd.read_csv("./screen_rfr.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+attr_latex: :width 120
[[file:screening_ops.png]]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+begin_src jupyter-python
  randdf = screen[~screen.Formula.str.contains(r"Pb", regex=False)].sort_values("DecoE_eV", ascending=True).head(10)
  randdf = randdf[["Formula", "bg_eV"]].rename(columns={"bg_eV":"band gap [eV]"})
  randdf
#+end_src

#+RESULTS:
:results:
\scriptsize
|       | Formula                             | band gap [eV] |
|-------+-------------------------------------+---------------|
| 19290 | FA0.375Rb0.625Sn1.000I1.000         |          1.98 |
| 19309 | FA0.375MA0.125Rb0.500Sn1.000Cl1.000 |          1.99 |
| 19310 | FA0.375MA0.125Rb0.500Sn1.000Br1.000 |          1.95 |
| 19306 | FA0.375MA0.125Rb0.500Sr1.000Cl1.000 |          1.95 |
| 19308 | FA0.375MA0.125Rb0.500Sn1.000I1.000  |          1.70 |
| 19307 | FA0.375MA0.125Rb0.500Sr1.000Br1.000 |          1.96 |
| 19304 | FA0.375Rb0.625Ba1.000Br1.000        |          1.93 |
| 19303 | FA0.375Rb0.625Ba1.000Cl1.000        |          1.89 |
| 19305 | FA0.375MA0.125Rb0.500Sr1.000I1.000  |          1.74 |
| 19302 | FA0.375Rb0.625Ba1.000I1.000         |          1.68 |
:end:

#+begin_src jupyter-python :post wrap(*this*, w="260pt")
  p = px.scatter(
      projdf,
      # facet_col='perplexity', facet_col_wrap=4,
      x='0', y='1',
      hover_name="Formula",
      color=(projdf.index.isin(screen.index)),
  )
  p.update_layout(
      legend_title="chosen", legend_itemsizing='constant',
      legend_orientation='h', legend_bgcolor="rgba(1,1,1,0)",
      legend_y=0.1,
      margin=dict(l=0, r=0, t=0, b=0),
      width=400, height=200
  )
  p.update_yaxes(matches=None, visible=False)
  p.update_xaxes(matches=None, visible=False)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 260pt
#+attr_org: :width 640
[[file:./.ob-jupyter/4d64b98962d2908713d9543efb9c28952a992b32.svg]]
:end:

** COMMENT compute distributions
#+begin_src jupyter-python
  dist = X_big.iloc[:,0:14].replace(
      0, np.NaN
  ).reindex(
      screen.index
  ).melt().dropna()

  dist[['site', 'Element']] = dist['variable'].str.replace(
      r"[\(\)']", "", regex=True
  ).str.split(
      ",", 1, expand=True
  )
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  def make_percent(df):
      df = df.assign(variable = df.variable / df.variable.sum() * 100)
      return df
#+end_src

#+RESULTS:
:results:
:end:

** Screened Constituent Frequencies                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+begin_src jupyter-python :post wrap(*this*, w="400pt")
  freq = dist.groupby(['value', 'site', 'Element']).count().reset_index().sort_values('site')

  p = make_subplots(cols=freq.site.unique().size, rows=1,
                    subplot_titles=("A-site", "B-site", "X-site"),
                    shared_xaxes=True)

  elnum = {'A': 5, 'B': 6, 'X': 3}

  for i, g in enumerate(freq.site.unique()):
      group = freq[freq.site == g].pipe(make_percent)
      colors = dict(zip(group['Element'].unique(), px.colors.qualitative.Plotly))
      traces = []
      for count, (element, sub) in enumerate(group.groupby('Element')):
          color_map = colors[element]
          traces.append(
              go.Bar(
                  x=sub['value'], y=sub['variable'], marker=dict(color=color_map),
                  name=(element if count < elnum[g]-1 else element + '                                                                       '),
                  legendgroup=g, #legendgrouptitle_text=g+'-site',
                  width=0.02
              )
          )
      for trace in traces:
          p.add_trace(trace, col=i+1, row=1)

      p.update_xaxes(
          title='Share of ' + g + ' Site',
          title_font_size=30,
          tickfont_size=24,
          tickmode='array',
          tickvals=np.linspace(0,1,9),
          ticktext=[f'{f.as_integer_ratio()[0]}/{f.as_integer_ratio()[1]}' for f in np.linspace(0,1,9)],
          col=i+1, row=1
      )
      p.update_yaxes(title="Element Frequency (%)",
                     title_font_size=30,
                     tickfont_size=24,
                     title_standoff=0)

  p.for_each_annotation(lambda a: a.update(font_size=30))

  p.update_layout(
      legend=dict(
          bgcolor='rgba(0,0,0,0)',
          orientation="h",
          xanchor='center',
          y=1.0, x=0.62,
          itemsizing='constant',
          font_size=20
      ),
      width=1500, 
  )
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 400pt
[[file:./.ob-jupyter/6319952505071b95f6f19f67c253faafb5f46d15.svg]]
:end:

*** A-site                                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- prefer occupying small fraction mixing in most constituents
- \(\ce{K}\) and \(\ce{Rb}\) also prefer full occupancy.

*** B-site                                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- favor full occupation a rate of 5-8%
- showed some preference approaching doping

*** X-site                                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- strongly prefer full occupation

* COMMENT CGCNN
** CGCNN Introduction                                              :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- uses pymatgen to make crystal graphs
- predefined sets of features for every atom involved in computation
  [cite:@xie-2018-cryst-graph]

* COMMENT MEGnet
** MEGnet Introduction                                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- uses pymatgen to make crystal graphs
- invites use of custom feature sets
  [cite:@ward-2016-gener-purpos;@chen-2019-graph-networ]
- MFGnet capable of multi-fidelity regressions
  [cite:@chen-2021-learn-proper;@chen-2020-multi-fidel]

* COMMENT Ongoing work
** band gap learning curve                                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 250pt
[[file:/home/panos/data/alignn/dist_bg_32_100/lc.svg]]
# - uses cgcnn feature set
** band gap parity                                                 :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+attr_latex: :width 250
[[file:/home/panos/data/alignn/dist_bg_32_100/pp.svg]]
*** Score                                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.3
:END:
| partition |     rmse |
|-----------+----------|
| test      | 0.063789 |
| train     | 0.211039 |
** COMMENT Decomposition Energy learning curve                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 250
[[file:/home/panos/data/alignn/dist_de_32_100/lc.svg]]
** COMMENT Decomposition Energy parity                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+attr_latex: :width 250
[[file:/home/panos/data/alignn/dist_de_32_100/pp.svg]]
*** Score                                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.3
:END:
| partition |     rmse |
|-----------+----------|
| test      | 0.012009 |
| train     | 0.081978 |

* Summary and Conclusions
** Seven Step Semiconductor Composition Optimization               :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
1. preexisting data set of ~500 samples from domain of ~40000 single-site mixed compositions
2. extract features using =cmcl=
3. train models of band gaps measured at multiple fidelities *using nine scoring criterion*
4. optimize model parameters while selecting for high scores in high-fidelity subsets using =yogi=
5. test best model, analyze accuracy, interpret predictions.
6. make predictions on *entire sample space*
7. screen for viable candidate compositions

** Conclusions                                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- RFR yields the best model because
  - it captures relevant feature interactions as corroborated by Pearson correlations
  - it flexibly represents nonlinear relationships between feature interactions and band gap
  - as an ensemble model, it reduces the variance of error
- SISSO is remarkably accurate for its simplicity but it is limited
  for high fidelity predictions due to the absence of some fidelity
  variables
- GPR has potential for further study alongside graph neural networks
- *834/1251 candidates are lead free*
- Top 10 most-stable lead-free compounds A-site mixed and mostly Iodides

** DONE Publications Presentations and Other Contributions         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-07 Wed 18:43]
:END:

*** Articles                                                :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.66
:BEAMER_env: block
:END:
\footnotesize
- Yang, J., Manganaris, P. T., & Mannodi Kanakkithodi, A. K. (2023). A high-throughput computational dataset of halide perovskite alloys. Digital Discovery, http://dx.doi.org/10.1039/d3dd00015j
- Manganaris, P., Yang, J., & Arun Mannodi Kanakkithodi (2023). Multi-fidelity machine learning pervoskite composition vs band gap. IN PREPARATION.
- Edlabadkar, R., Yang, J., Rahman, H., Manganaris, P., Korimilli, E. P., & Arun Mannodi-Kanakkithodi (TBD). Driving Halide Perovskite Discovery Using Graph Neural Networks. IN PREPARATION.
- Gollapalli, P., Manganaris, P., & Arun Mannodi-Kanakkithodi (TBD). Graph neural network predictions for formation energy of native defects in zinc blende semiconductors. IN PREPARATION.
- Yang, J., Manganaris, P., & Arun Mannodi-Kanakkithodi (TBD). Discovering novel halide perovskite alloys using multi-fidelity machine learning and genetic algorithm. IN PREPARATION.
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.33
:END:
**** Presentations                                               :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
\footnotesize
- Poster for DS02 symposium MRS fall 2022
- Talk for Purdue Soft Materials symposium
- developed MRS spring 2022 tutorial hosted on nanoHUB
**** Software                                                    :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
\footnotesize
https://github.com/PanayotisManganaris/
- =cmcl=
- =yogi=
- =spyglass=
- =pysisso=

* Credit
** Acknowledgements                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
**** Research Group                                              :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
I am grateful to
- Professor Arun Mannodi-Kanakkithodi for his mentorship, support, and knowledge.
- Professor Erk for her guidance and council
- Professor Strachan for his instruction
- Jiaqi Yang for his collaboration
- Habibur Rahman for his friendship and curiosity
**** COMMENT Experimental Collaborators                          :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Thanks to Professor David Fenning, Dr. Rishi Kumar for working with us
to validate simulations and predictions.
**** Funding                                                     :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- Ross Fellowship
- Professor Arun's startup research grant
# F.10023800.05.002
**** Resources                                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
RCAC Bell Computing Cluster
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+LATEX: \hspace*{-1cm}
#+attr_latex: :width 200 :center nil
[[file:~/Pictures/mrg-photoshoot/41_Kanakkithodi.jpg]]
* Bib
** References                                                      :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:BEAMER_opt: allowframebreaks
:END:
#+LATEX:\AtNextBibliography{\tiny}
#+LATEX:\printbibliography
* SI                                                             :B_appendix:
:PROPERTIES:
:BEAMER_env: appendix
:END:
# add tbl comparing MatBench to Mine
** Interpreting t-SNE clusters                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

# fix blue/green on projector
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

#+begin_src jupyter-python :post wrap(*this*, w="200pt")
  p = px.scatter(
      projdf,
      x='0', y='1',
      hover_name="Formula",
      color='mix',
  )
  p.update_layout(
      legend_title="chosen", legend_itemsizing='constant',
      legend_orientation='h', legend_bgcolor="rgba(1,1,1,0)",
      legend_y=0.05,
      margin=dict(l=0, r=0, t=0, b=0),
      width=400, height=400
  )
  p.update_yaxes(matches=None, visible=False)
  p.update_xaxes(matches=None, visible=False)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 200pt
#+attr_org: :width 640
[[file:./.ob-jupyter/c7002c894b6ade243f089aabdefcb2c2b4d07a89.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

#+begin_src jupyter-python :post wrap(*this*, w="200pt")
  p = px.scatter(
      projdf,
      x='0', y='1',
      hover_name="Formula",
      color='org',
  )
  p.update_layout(
      legend_title="chosen", legend_itemsizing='constant',
      legend_orientation='h', legend_bgcolor="rgba(1,1,1,0)",
      legend_y=0.05,
      margin=dict(l=0, r=0, t=0, b=0),
      width=400, height=400
  )
  p.update_yaxes(matches=None, visible=False)
  p.update_xaxes(matches=None, visible=False)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 200pt
#+attr_org: :width 640
[[file:./.ob-jupyter/bd7813d2d1d9cd1108cdd457bd977e8fd1a6aa99.svg]]
:end:

** Future Work                                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
\[
\hat{y}_i = y_i + \epsilon_i \mbox{ for observations } i=1,,N
\]

multi-fidelity learning *is* regression on heteroscedastic data

- high fidelity :: prior on \(\epsilon_i\) is narrow
- low fidelity :: prior on \(\epsilon_i\) is wide
  
e.g \(\epsilon_i \sim N(0,\sigma_i^2)\), with \(\sigma_i^2\) being a function of fidelity

- find a way to bias RFR training using prior information
- avoid OHE which adds additional sparse features which increases training expense.

** Data Pre-Processing                                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 300
[[file:~/Pictures/flowcharts/data_proc.png]]
\center{}Data pre-processing workflow implemented with Python Pandas

** SHAP Analyze GPR                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+DOWNLOADED: screenshot @ 2023-05-24 09:42:08
#+attr_latex: :width 350
[[file:Models/2023-05-24_09-42-08_screenshot.png]]

** SHAP Analyze SIS Features in RFR                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+attr_latex: :width 400pt
[[file:/home/panos/Documents/manuscripts/DFT+ML+feature_engineering/RFR/.ob-jupyter/d0b6ba16e4913fe81324e8170b2b5b241c1053c8.png]]

** Compare to State of the Art Band Gap Predictions                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- my models are not directly comparable with published leaders
  - specialized for perovskites
  - utilize multi-fidelity data
- I've not yet tried them for other classes of materials
- They *are* compatible with this benchmark

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
\scriptsize
| RFR perovskite compositions          | 0.0805 | 0.1247 |
|--------------------------------------+--------+--------|
| models of MatProj DFT band gaps      |    MAE |   RMSE |
|--------------------------------------+--------+--------|
| coGN                                 | 0.1559 | 0.3956 |
| ALIGNN                               | 0.1861 | 0.4635 |
| MegNet (kgcnn v2.1.0)                | 0.1934 | 0.4715 |
| DimeNet++ (kgcnn v2.1.0)             | 0.1993 | 0.4720 |
| Finder_v1.2 structure-based version  | 0.2193 | 0.4989 |
| MODNet (v0.1.10)                     | 0.2199 | 0.4525 |
| MODNet (v0.1.12)                     | 0.2199 | 0.4525 |
| Finder_v1.2 composition-only version | 0.2308 | 0.4837 |
| SchNet (kgcnn v2.1.0)                | 0.2352 | 0.5172 |
| CrabNet                              | 0.2655 | 0.5898 |
| AMMExpress v2020                     | 0.2824 | 0.5611 |
| CGCNN v2019                          | 0.2972 | 0.6771 |
| RF-SCM/Magpie                        | 0.3452 | 0.6125 |
| Dummy                                | 1.3272 | 1.5989 |

** DONE Density Functional Theory (DFT)                            :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-06-03 Sat 13:44]
:END:

- Higher levels of theory (LoT) approximations of \(\hat{U}(n)\) account for more physics.
- VASP is used to perform these calculations at the appropriate LoT.
  [cite:@kresse-1996-effic-iterat;@kresse-1996-effic-ab]
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
Recast \(3n\)-D Schrdinger equation as \(n\) \(3\)-D Kohn-Sham equations
\[
\left(-\frac{\hbar^2}{2m}\nabla+\hat{V}_s\right)\psi(r_k) = \epsilon_k\psi(r_k)
\]

Solutions yield the local electron densities
\[
n(r) = \sum_{i=1}^n|\psi_i(r)|^2
\]

which can be used to minimize \(E(n)\).

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
# Minimization converges to ground state configuration by Hohenberg-Kohn theorem.

# \[
# n(r_k) = \int \prod_{i=1}^{k-1}d^3r_i\prod_{i=k+1}^{n}d^3r_i|\psi(r_k, \{r_i\})|^2
# \]

Express potential energy due to the nuclei using density \(n(r)\)
given at \(r_k\) by marginalizing the wave function over all \(r_{\neg k}\)

\[
\hat{V}(n) = \int \hat{V}_{nuc}(r_k)n(r_k)d^3r
\].

So only electron-electron interaction term \(\hat{U}(n)\) requires approximation

\[
E = \bra{\psi}\hat{H}\ket{\psi} \implies E(n) &= \hat{T}(n) + \hat{U}(n) + \hat{V}(n)
\]

* Footnotes

[fn:3]\tiny{}https://github.com/PanayotisManganaris/yogi
[fn:2]\tiny{}[[https://www.lesker.com/newweb/ped/applications/perovskite-research.cfm ][www.lesker.com]]
[fn:1]\tiny{}Photo by Dennis Schroeder\newline{}National Renewable Energy Laboratory

# :var c=""
# \n#+CAPTION: $c
#+NAME: wrap
#+begin_src bash :var p="" :var w="300pt"
  echo -ne "$p \n#+attr_latex: :width $w"
#+end_src

#+NAME: wraptbl
#+begin_src bash :var p="" :var w="300pt" :var c=""
  echo -ne "$p \n#+CAPTION: $c "
#+end_src
