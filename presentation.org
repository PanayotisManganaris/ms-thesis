#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:("TODO" "DONE" "NEXT") tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: \Huge{}Machine Learning Perovskite Bandgaps for Improved Photovoltaics
#+author: \large{}Panayotis Manganaris\inst{1}
#+email: panos.manganaris@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.2 (Org mode 9.5.5)
#+cite_export: biblatex
#+bibliography: local-bib.bib
#+latex_class: beamer
#+latex_class_options: [10pt, aspectratio=169, presentation]
#+latex_header:
#+latex_header_extra:\institute[Mannodi Group]{\large{}
#+latex_header_extra:\inst{1} Purdue Materials Engineering\\Advisor Arun Mannodi-Kanakkithodi
#+latex_header_extra:}
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex
#+date: \today
#+setupfile: ~/org/beamer_header.org
#+PROPERTY: header-args:jupyter-python :session mrg :kernel mrg :pandoc org :async yes
#+PROPERTY: header-args :results scalar drawer :eval never-export :exports results
* COMMENT dependencies
#+INCLUDE: /home/panos/Documents/manuscripts/DFT+ML+feature_engineering/dependencies.org
#+begin_src jupyter-python
  import datetime
  import io
#+end_src

#+RESULTS:
:results:
:end:

* COMMENT setup codes
#+begin_src jupyter-python
  class QEParser():
      def __init__(self, filepath):
          """
          Parse Quantum Espresso Electronic Structure Output files.

          instantiate QEParser with a path to a QE output file

          call get_df method to return a long dataframe
          """
          with open(filepath) as f:
              lines = f.readlines()
          self.dstrings = "".join(lines)
          self.nameblock = re.compile(r"[-.]+\n [A-Za-z0-9\.\s\(#\)-]+[-.]+")

      def string_pop(self, string, delimiter):
          """ strings are immutable,
          so this reassigns dstring after splitting """
          datalist = string.split(delimiter)
          data = datalist.pop(0)
          self.dstrings = "".join(datalist)
          return data

      def get_df(self):
          """produce dataframe from init file"""
          nameblocks = re.findall(self.nameblock, self.dstrings)
          names = list(map(lambda s: s.split("\n")[1:-1], nameblocks))
          dfs=[]
          self.dstrings = self.dstrings.replace(nameblocks.pop(0),"")
          for block,name in zip(nameblocks, names):
              dstring = self.string_pop(self.dstrings, block)
              name="\n".join(name).replace(" ", "_").replace("_", "", 1)
              sio = io.StringIO(dstring, newline='\n')
              dfs.append(
                  pd.read_csv(
                      sio, header=0, on_bad_lines='warn'
                  ).assign(name=name)
              )
              sio = io.StringIO(self.dstrings, newline='\n')
          name="\n".join(names[-1]).replace(" ", "_").replace("_", "", 1)
          dfs.append(
              pd.read_csv(
                  sio, header=0, on_bad_lines='warn'
              ).assign(name=name)
          )
          return pd.concat(dfs, axis=0)
#+end_src

#+RESULTS:
:results:
:end:

* COMMENT load and pre-process sample
#+begin_src jupyter-python
  Xt = pd.read_csv("./X_t.csv", index_col=0)
  Xc = pd.read_csv("./X_c.csv", index_col=0)
  Xp = pd.read_csv("./X_p.csv", index_col=0)
  X = Xt
  Y = pd.read_csv("./Y.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  X_big = pd.read_csv("./X_big.csv", index_col=0)
  Y_big = pd.read_csv("./Y_big.csv", index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

** create preprocessing pipeline
#+begin_src jupyter-python
  comp_features = Xc.columns
  prop_features = Xp.columns
  cat_features = Xt.select_dtypes('object').columns

  # define preprocessing
  fillna = SimpleImputer(strategy="constant", fill_value=0.0)
  mkratio = Normalizer(norm='l1')
  mknormal = StandardScaler()
  mkbound = MinMaxScaler(feature_range=(0,1), clip=False) #not statistical, should work for anything

  comp_transformer = make_pipeline(fillna, mkratio, mkbound)
  prop_transformer = make_pipeline(fillna, mknormal, mkbound)
  cat_transformer = ohe(handle_unknown="ignore")

  preprocessor = ColumnTransformer(
      transformers=[
          ("comp", comp_transformer, comp_features),
          ("prop", prop_transformer, prop_features),
          ("cat", cat_transformer, cat_features),
      ]
  )
#+end_src

#+RESULTS:
:results:
:end:

** apply preprocessing to Domain samples
#+begin_src jupyter-python
  preprocessor.fit(X)
#+end_src

#+RESULTS:
:results:
#+begin_example
  ColumnTransformer(transformers=[('comp',
                                   Pipeline(steps=[('simpleimputer',
                                                    SimpleImputer(fill_value=0.0,
                                                                  strategy='constant')),
                                                   ('normalizer',
                                                    Normalizer(norm='l1')),
                                                   ('minmaxscaler',
                                                    MinMaxScaler())]),
                                   Index(['('A', 'Cs')', '('A', 'FA')', '('A', 'K')', '('A', 'MA')',
         '('A', 'Rb')', '('B', 'Ba')', '('B', 'Ca')', '('B', 'Ge')',
         '('B', 'Pb')', '('B', 'Sn')', '('B', 'Sr')', '('X',...
         '('X', 'melting_point_K')', '('X', 'density_gpercc')',
         '('X', 'atomic_weight_u')', '('X', 'electron_affinity_kJpermol')',
         '('X', 'ionization_energy_kJpermol')',
         '('X', 'heat_of_fusion_kJpermol')', '('X', 'heat_of_vap_kJpermol')',
         '('X', 'electronegativity')', '('X', 'at_num')', '('X', 'period')'],
        dtype='object')),
                                  ('cat', OneHotEncoder(handle_unknown='ignore'),
                                   Index(['LoT'], dtype='object'))])
#+end_example
:end:

#+begin_src jupyter-python
  XX = pd.DataFrame(preprocessor.transform(X),
                   columns=preprocessor.get_feature_names_out(),
                   index=X.index)
  XX_big = pd.DataFrame(preprocessor.transform(X_big),
                   columns=preprocessor.get_feature_names_out(),
                   index=X_big.index)
#+end_src

#+RESULTS:
:results:
:end:

** apply preprocessing to codomain samples
no target transformations yet
#+begin_src jupyter-python
  # YY = Y
#+end_src

#+RESULTS:
:results:
:end:

* Background
# Introduce PVs
# - the band gap controls the lowest energy photon that can be absorbed
# - perovskites demonstrate good transport
# establish recent context
# - advancements
# - other applications
# what perovskites are and why you should care
# 1. familiar BaTiO3
# 2. halide perovskites
# Combinatorial Mixing in-depth Discussion
# - discuss properties which contribute to this performance
# - why we need computational methods
** DONE Photovoltaic (PV) Power Generation                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-22 Mon 16:19]
:END:
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+attr_latex: :width 100
[[file:thin-film-PV.png]]
#+attr_latex: :width 90
[[file:Si-HaP-tandem-PV.png]]

\tiny{}\center{}Perovskite Applications[fn:2]

**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
***** Band Gap Effects on Absorption Spectrum                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
****** col                                                       :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src jupyter-python
  df = QEParser('/home/panos/Documents/masters/GaN_ZB_AS.txt').get_df()
#+end_src

#+begin_src jupyter-python :post wrap(*this*, w="130pt")
  p0 = make_subplots(rows=2, cols=1, shared_xaxes=True)

  p1 = px.line(df, x='Wavelength (nm)', y=' Absorption Coefficient', color='name',
              height=200, width = 400,)
  p1.update_yaxes(title='alpha')

  p0.add_trace(p1.data[0], row=1, col=1)
  colorsteps = 750
  p0.add_trace(go.Bar(
      y=['spectrum']*colorsteps,
      x=[1]*colorsteps,
      orientation='h',
      marker=dict(
          color=list(range(colorsteps)),
          colorscale='Rainbow',
          cmin=103,
          cmax=750,
          showscale=False
      )
  ), row=2, col=1)

  p0.update_xaxes(range=[103, 750])
  p0.update_yaxes(visible=False, row=2, col=1)

  p0.add_vline(x=628.019, annotation_text='628 nm', annotation_font_size=40,
               line_color='black', line_width=2, row=1, col=1)
  p0.update_layout(
      showlegend=False,
      margin=dict(t=0,b=0,l=0,r=0),
      yaxis_domain = [0.1, 1.0], yaxis2_domain = [0.0, 0.1]
  )
  p0.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 130pt
[[file:./.ob-jupyter/cccae4e4cfe972af740ccc5c35b127fa19f8c26b.svg]]
:end:

****** col                                                       :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

\begin{align*}
E_\gamma = \hbar\omega &= bg\,\si{\joule} \\
\implies \frac{hc}{628\,\si{\nano\meter}} &= 3.16\times{}10^{-19}\,\si{\joule}\\
&= 1.97\,\si{\electronvolt}
\end{align*}

***** Perovskite Semiconductors in Solar Energy Harvesting      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- 2009 : \(\ce{MAPbI_3}\) dye-sensitized absorber with 3.8% PCE
  [cite:@kojima-2009-organ-halid]
- 2011 : absorber efficiency doubles
  [cite:@im-2011]
- 2013 : \(\ce{MAPbX_3}\) found to transport holes+electrons
  [cite:@saliba-2014-influen-therm]

HaP PVs become competitive in 2013
** NEXT Rapid Rise of Perovskite Photovoltaics                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "NEXT"       from              [2023-05-22 Mon 17:08]
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:

#+DOWNLOADED: screenshot @ 2023-05-15 18:16:32
#+attr_latex: :width 250pt
[[file:Perovskites/2023-05-15_18-16-32_screenshot.png]]

*** COMMENT col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src jupyter-python
  history = pd.read_csv('~/data/perovskites/NREL-pvcell-efficiency.csv', index_col=0)
  x = "Measurement Date"
  y = "Combined efficiency (%)"

  history[x] = history[x].apply(lambda x: datetime.datetime.strptime(x, '%m/%d/%Y'))
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(w="280pt")
  color_map = {
      ('Crystalline Si Cells', 'Single crystal (non-concentrator)'): px.colors.qualitative.Plotly[0],
      ('Emerging PV', 'Perovskite cells'): px.colors.qualitative.Plotly[1],
      ('Single-Junction GaAs', 'Single crystal'): px.colors.qualitative.Plotly[0],
      ('Emerging PV', 'Perovskite/Si tandem (monolithic)'): px.colors.qualitative.Plotly[1],
      ('Thin-Film Technologies', 'CdTe'): px.colors.qualitative.Plotly[2],
  }

  traces = []
  for (cat1, cat2), g in history.groupby(
      ["Eff. Chart Material Class", "Eff. Chart Cell Type"]
  ):
      if (cat1, cat2) in color_map.keys():
          best = g.groupby(x).max(y)[y].cummax()
          trace = go.Scatter(
              x=best.index,
              y=best,
              name=f'{cat1}-{cat2}',
              line_color=color_map[(cat1, cat2)],
              mode='lines+markers'
          )
          traces.append(trace)

  # Create the layout
  layout = go.Layout(
      xaxis_title=x, yaxis_title=y,
      legend=dict(orientation="h", y=1.1)
  )

  p = go.Figure(data=traces, layout=layout)
  p.update_xaxes(
      minor=dict(ticks="inside", showgrid=True)
  )
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 280pt
[[file:./.ob-jupyter/5a70cef7f43718d2462f4328daceef604482623e.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- Cumulative maximum efficiency of PVs tested by accredited laboratories[cite:@research-2023-best-resear]
- Perovskite+Si tandem monolithic cells second only to two-junction \(\ce{GaAs}\)
- Other rising applications
  - LEDs and photodiodes
  - infrared sensors
  - superconductors
  - quantum bits

** DONE What's a Perovskite?                                       :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-22 Mon 17:08]
:END:
# relaxor : character w/ highly nonlinear dielectric constant and
# diffused ferroelectric to para electric phase transition (no well
# defined Curie temperature)
*** Oxide Perovskites                                     :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Notable oxide perovskites and properties circa 2006
[cite:@jiang-2006-predic-lattic]
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
\small
| <K,Ba>BiO3  | super-conduction      |
| Pb<Zr,Ti>O3 | piezoelectric action  |
| Pb<Mb,Mg>O3 | relaxor ferroelectric |
| BaTiO3      | dielectric properties |
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
\small
| Pb<Zr,Ti>O3 | electro-optic         |
| LaMnO3      | magneto-resistance    |
| LaCrO3      | catalytic             |
| BaCeO3      | photonic conductivity |
*** fig                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+DOWNLOADED: screenshot @ 2022-07-14 15:32:57
#+CAPTION: Barium Titanate functional ceramic
#+attr_latex: :width 170
[[file:Introduction_To_Perovskites/2022-07-14_15-32-57_screenshot.png]]

** DONE Halide Perovskites                                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-23 Tue 10:45]
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
- purely inorganic (e.g., CsPbI3)
- hybrid organic-inorganic (e.g., MAPbBr3)
  - MA :: methylammonium
  - FA :: formamidium
- tailor stability and electronic/optical properties of \(\ce{ABX3}\)
  compounds by changing
  - component at each site
  - mix of components
  - atom arrangement
# structure, octahedral arrangements, point defects, interfaces, etc.

#+caption: \(\ce{ABX3}\) Site Candidates
| /      | <  |    |    |    |    |    |
| A-site | MA | FA | Cs | Rb | K  |    |
| B-site | Pb | Sn | Ge | Ba | Sr | Ca |
| X-site | I  | Br | Cl |    |    |    |

*** COMMENT col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+DOWNLOADED: screenshot @ 2022-07-15 23:57:31
#+attr_latex: :width 115
[[file:Introduction_To_Perovskites/2022-07-15_23-57-31_screenshot.png]]
Perovskite Solar Absorber Layer[fn:1]
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+attr_latex: :width 140
[[file:hybrid-HaP.png]]

\center{}2x1x2 supercell

** DONE Design Goals and Challenges of Combinatorial Mixing        :B_frame:
** DONE Perovskite Formability                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
- State "DONE"       from "TODO"       [2023-05-25 Thu 16:16]
:END:
**** Search for Improved Compounds                               :B_block:
- A must be much larger than B for Perovskite formation
- Various tolerance factors have been designed to describe this constraint
- B usually large (e.g. Pb, Sn) in Halide Perovskites
- A accommodates amines with large effective ionic radii[cite:@kieslich-2015-exten-toler]
- for \alpha phase stability
[cite:@yin-2015-halid-perov;@bartel-2019-new-toler]

*** Goldschmidt tolerance                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.33
:END:

*37,785* out of *207+ Million* compounds possible in a 2x2x2 supercell
will be examined for solutions to these deficiencies using
- high-throughput density functional theory
- data collected from literature
- multi-fidelity machine learning
\[
1 \approx t = \frac{R_A+R_X}{\sqrt{2}*(R_B+R_X)}
\]

# combinatorial growth of composition space with
# 1. size of supercell
# 2. constituent options
**** fig mixing                                          :B_ignoreheading:
*** Octahedral Factor                                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.33
:END:
#+begin_src jupyter-python :post wrap(*this*, w="150pt :options inkscapeformat=png, inkscapedpi=300")
    p = px.sunburst(Y_big, path=['mix'])
    p.update_layout(
        margin=dict(l=0, r=0, t=0, b=0),
        font_size=60
    )
    p.update_traces(insidetextorientation='horizontal',
                    textinfo="label+value")
    llist = p.data[0].labels
    p.data[0].labels = [l + '-site mixed' for l in llist]
    p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 150pt :options inkscapeformat=png, inkscapedpi=300
[[file:./.ob-jupyter/3ed5c0e44a1db77d1bd67911c688251d563c2ef0.svg]]
:end:
\[
0.67 \approx o=\frac{r_B}{r_X}
\]

*** Bartel Tolerance                                        :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.33
:END:

\[
4.0 \gtrapprox t_{Bartel}=\frac{r_X}{r_B}-[1-\frac{\frac{r_A}{r_B}}{ln(\frac{r_A}{r_B})}]
\]

:PROPERTIES:
:BEAMER_env: block
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
**** fig all components                                  :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+begin_src jupyter-python :post wrap(*this*, w="150pt :options inkscapeformat=png, inkscapedpi=300")
  p = px.sunburst(XX_big.iloc[:,1:14].replace(0,np.NaN)
                    .join(Y_big[['mix']])
                    .groupby(['mix'])
                    .sum().reset_index().melt(id_vars=['mix']),
                  path=['variable'], values='value')
  p.update_traces(insidetextorientation='horizontal',
                  textinfo="label+percent parent")

  p.update_layout(
      margin=dict(l=0, r=0, t=0, b=0),
      font_size=30
  )
  llist = p.data[0].labels
  p.data[0].labels = [re.sub("comp__|['\(\),)]", "", l) for l in llist]
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 150pt :options inkscapeformat=png, inkscapedpi=300
[[file:./.ob-jupyter/e5dedf8aa3764c0a663c1bbbd2d70eef512cfa96.svg]]
:end:

**** Deficiencies in Leading Perovskite PVs                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
inherent instability/short life-cycle
- degradation in sunlight
- soluble in water
environmental impact
- toxicity of Lead (Pb)

** COMMENT Attractive Properties of Perovskites                            :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+DOWNLOADED: screenshot @ 2022-07-16 01:34:42
#+attr_latex: :width 200
[[file:Introduction_To_Perovskites/2022-07-16_01-34-42_screenshot.png]]
Typical severity of gap states
[cite:@mannodi-kanakkithodi-2020-defec-energ]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- robust against carrier scattering
  [cite:@yan-2016-defec-physic]
- spontaneously forming high energy defects unlikely
- edge-states
- finite internal dipole moments
  [cite:@hong-2021-layer-edge]
  - ferroellectrically aligned ligands
  - long luminescence lifetimes
- hydro-stability
  [cite:@fu-2021-two-dimen]
  - hydrophobic ligands

** COMMENT Hybrid Organic-Inorganic Perovskites                            :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+DOWNLOADED: screenshot @ 2022-07-18 13:42:36
#+attr_latex: :height 90
#+attr_org: :width 90
[[file:Introduction_To_Perovskites/2022-07-18_13-42-36_screenshot.png]]

\(\alpha\)-Phase \(Pm\bar{3}m\) Hybrid Perovskite Crystal
[cite:@yan-2016-defec-physic]

\(\ce{ABX3}\) with \(\ce{A=CH3NH3+}\) (MA)
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+DOWNLOADED: screenshot @ 2022-07-13 19:55:58
#+attr_latex: :height 90 :options angle=90
#+attr_org: :width 90
[[file:Introduction_To_Perovskites/2022-07-13_19-55-58_screenshot.png]]
2-D Ruddlesden-Popper \(Pbca\) Hybrid Perovskite Crystal
[cite:@hong-2021-layer-edge]

\(\ce{L_2BX_4}\) with \(\ce{L=C4H12N+}\) (BA)

Generalizes to LA_{m-1}B_{m}X_{3m+1} perovskite with m>1

* Computational Methods In Materials Science
# discuss DDMD in group context + introduce DFT and ML
# discuss DFT in general -- distance myself from data
# - why dft? uses quantum mechanics -- still expensive big integral
# be prepared to discuss functionals
# combinatorially scaling chemical space
# bandgaps are unpredictably deviating away from Vegard's law.
** Density Functional Theory (DFT)                                 :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
Very impractical to explore combinatorial search space with laboratory experiments

VASP /in silico/ simulation gives more direct, more systematic, less accurate sampling
[cite:@kresse-1996-effic-iterat;@kresse-1996-effic-ab]

** Machine Learning for Property Prediction                        :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+DOWNLOADED: screenshot @ 2023-05-24 04:42:21
#+attr_latex: :width 300
[[file:Computational_Methods_In_Materials_Science/2023-05-24_04-42-21_screenshot.png]]


*** Applications                                            :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
predict anything/make decisions[cite:@pablo-2019-new-front]
- interatomic force fields
- predict properties
- classify observations

** Relevant Property Prediction from Literature                    :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+DOWNLOADED: screenshot @ 2023-05-24 05:33:49
[[file:Computational_Methods_In_Materials_Science/2023-05-24_05-33-49_screenshot.png]]

HSE06 improve band gap predictions compared to PBE[cite:@chan-2010-effic-band]

** DONE Data Driven Materials Design                               :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 04:30]
:END:
#+attr_latex: :width 390
#+attr_org: :width 90
[[file:DDD-flowchart.png]]
\center{}\vspace{-0.5cm}Workflow for accelerating testing and development of new PV materials
[cite:@yang-2023-high-throug;@pablo-2019-new-front]

** DONE Random Forest Regression (RFR)                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 04:27]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+DOWNLOADED: screenshot @ 2023-05-23 20:23:36
#+attr_latex: :width 260
[[file:Computational_Methods_In_Materials_Science/2023-05-23_20-23-36_screenshot.png]]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- trees capture interactions between feature 
- trees are flexible and may be highly biased to data
- forest explains variance in data
- forest reduces the variance of error

** DONE Gaussian Process Regression (GPR)                          :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 04:27]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
Universal approximator based on Bayesian analysis.
**** Kernel Method                                               :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
the similarity function \(k(x, x')\)
- defines a "universe" of functions
- defines a density of functions prior to any data
- \(x\) is any descriptor describable as self-similar
**** Drawbacks                                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- \(\mathcal{O}(N^3)\) training time complexity
- kernels require engineering to accommodate prior expectations
- break down in sparse spaces/high-dimensional spaces

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
**** COMMENT functions illustration
#+begin_src jupyter-python
    from sklearn.gaussian_process import kernels as K
    from sklearn.gaussian_process import GaussianProcessRegressor
    kerns = [
        K.DotProduct(),      
        1.0 * K.RBF(length_scale=1.0, length_scale_bounds=(1e-1, 10.0))
    ]
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python
  def plot_density_samples(gpr_model, n_sample):
      x = np.linspace(0, 5, 100)
      x = x.reshape(-1, 1)
      y_mean, y_std = gpr_model.predict(x, return_std=True)
      y = gpr_model.sample_y(x, n_sample)
      df = pd.DataFrame(np.c_[x, y]).set_index(0)
      p = px.line(df)
      p.add_scatter(x=x.reshape(-1), y=y_mean,
                    mode='lines', line_width=5,
                    line_color='black', name='ridge')
      return p
#+end_src

#+RESULTS:
:results:
:end:

**** Sample Prior Functions                                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :post wrap(*this*, w="170pt")
  gpr = GaussianProcessRegressor(kernel=kerns[1], random_state=None)

  p = plot_density_samples(gpr, 5)
  p.update_layout(showlegend=False,
                  margin=dict(l=0, r=0, t=0, b=0),
                  width=400, height=150)
  p.update_xaxes(title="", tickfont_size=20)
  p.update_yaxes(title="", tickfont_size=20)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 170pt
#+attr_org: :width 640
[[file:./.ob-jupyter/ec4d60a2109843449bb674d71a67240d13c1611a.svg]]
:end:

**** Sample Posteriors                                           :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python
  rng = np.random.RandomState(4)
  x_train = rng.uniform(0, 5, 10).reshape(-1, 1)
  y_train = np.sin((x_train[:, 0] - 2.5) ** 2)
  n_samples = 1
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*, w="170pt")
  gpr.fit(x_train, y_train)

  p = plot_density_samples(gpr, 5)
  p.update_layout(showlegend=False,
                  margin=dict(l=0, r=0, t=0, b=0),
                  width=400, height=150)
  p.update_xaxes(title="", tickfont_size=20, range=(0,5))
  p.update_yaxes(title="", tickfont_size=20)

  p.add_scatter(x=x_train.reshape(-1), y=y_train, mode="markers", marker_color='red', marker_size=10)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 170pt
#+attr_org: :width 640
[[file:./.ob-jupyter/eeae18f97963b2846566f847fcd1a8bb5dd88175.svg]]
:end:

** DONE Sure-Independence Screening and Sparsifying Operator (SISSO) :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
:LOGBOOK:
- State "DONE"       from              [2023-05-24 Wed 05:08]
:END:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
generalizes "Greedy Pursuit" algorithms
- Orthogonal Matching Pursuit
- Basis Pursuit (aka LASSO)

SIS+correlation analysis is a form of orthogonalization

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+DOWNLOADED: screenshot @ 2022-12-20 09:09:33
#+attr_latex: :width 250
[[file:Computational_Methods_In_Materials_Science/2022-12-20_09-09-33_screenshot.png]]
Notice SIS re-iterations explain the residual[cite:@ghiringhelli-2017-learn-physic]

** COMMENT Motives for Alternative Features                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** Plan of Investigation                                         :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
1. relate various bulk properties of molecules to performance of
   existing perovskite solar absorbers
2. extrapolate into the unknown
*** Known Organic Constituents currently in use                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Literature provides examples of known performant ligands:
- Methylammonium (Cationic Methylamine)
  [cite:@yan-2016-defec-physic]
- Formamidium (Cationic Formamidine)
  [cite:@dimesso-2016-inves-formam]
- Guanidinium (Cationic Guanidine)
  [cite:@zhang-2019-perov-photov]
- Butylammonium (Cationic Butylamine)
  [cite:@hong-2021-layer-edge]

* Data
# model bg because 
# - bg models are more generally useful than SLME
# - SLME is more expensive to compute

# rationalize the use of various features in models
# explain the features vectors, illustrate them graphically somehow
# codomain side
# - choose to model perovskite band gaps per SQ criterion
# domain side
# - various empirical tolerance factors used in screening
# - discuss use of Electronegativity, etc, etc
# pearson plots solidify the vector concept
# - Show Correlations with each LoT!
** Effect of DFT Functionals Levels of Theory                      :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+DOWNLOADED: screenshot @ 2023-05-15 20:04:18
#+latex_attr: :width 400
[[file:Data/2023-05-15_20-04-18_screenshot.png]]

** Band Gap Relates to Efficiency                                  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src jupyter-python :post wrap(*this*, w="210pt")
  p = px.scatter(Y[Y.LoT == "EXP"], x="bg_eV", y="efficiency", color="mix")
  p.update_xaxes(range=(0, 4), title="Band Gap [eV]")
  p.update_yaxes(range=(0, 0.25), title="Power Conversion Efficiency")
  p.update_layout(showlegend=False,
                  xaxis_tickfont_size=20, yaxis_tickfont_size=20,
                  xaxis_titlefont_size=24, yaxis_titlefont_size=24)
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 210pt
[[file:./.ob-jupyter/2b677464785e9d1d299f0f955a3af16e9c3b5f7e.svg]]
:end:

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src jupyter-python :post wrap(*this*, w="210pt")
  p = px.scatter(Y[Y.LoT == "PBE"], x="bg_eV", y="efficiency", color="mix")
  p.update_xaxes(range=(0, 4), title="Band Gap [eV]")
  p.update_yaxes(range=(0, 0.25), title="SLME")
  p.update_layout(xaxis_tickfont_size=20, yaxis_tickfont_size=20,
                  xaxis_titlefont_size=24, yaxis_titlefont_size=24)
  # Add screening lines
  h_lin1 = go.layout.Shape(type='line',
                           x0=1.0, y0=0.0,
                           x1=1.0, y1=0.25,
                           line=dict(color='black', width=2))
  h_lin2 = go.layout.Shape(type='line',
                           x0=2.5, y0=0.0,
                           x1=2.5, y1=0.25,
                           line=dict(color='black', width=2))
  v_line = go.layout.Shape(type='line',
                           x0=0.0, y0=0.15,
                           x1=4.0, y1=0.15,
                           line=dict(color='black', width=2))
  rect = go.layout.Shape(type='rect', #line=dict(color='blue', width=2)
                         x0=1.0, y0=0.15,
                         x1=2.5, y1=0.25,
                         fillcolor='blue', opacity=0.2)
  p.add_shape(h_lin1)
  p.add_shape(h_lin2)
  p.add_shape(v_line)
  p.add_shape(rect)

  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 210pt
[[file:./.ob-jupyter/0c4832ea502cef117df59890aa3341839c46147b.svg]]
:end:

*** non                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
SLME (proxy for PCE[cite:@almora-2020-devic-perfor]) accounts for more energetic processes than
Shockley-Queisser criterion (\(bg \approx 1.3\)) allowing selection on range
of bandgaps determined according to level of theory[cite:@yu-2012-ident-poten p.1]

[cite:@yang-2023-high-throug]

** Collecting Data is Hard                                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
experiments take years and, until recently, much labor to collect
[cite:@almora-2020-devic-perfor]
#+DOWNLOADED: screenshot @ 2023-05-24 08:01:24
#+attr_latex: :width 200
[[file:Data/2023-05-24_08-01-24_screenshot.png]]

 DFT calculations take multiple
- hours to converge at PBE level
- days to converge at HSE level
- days more to debug
accumulating the HaP dataset took years
[cite:@yang-2023-high-throug]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+begin_src jupyter-python
  Y = pd.read_csv(
      "~/Documents/manuscripts/DFT+ML+feature_engineering/Y.csv",
      index_col=0
  )
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*, w="120pt")
    p = px.box(Y, y="bg_eV", x="LoT",
               width=400, height=700)
    p.update_xaxes(title_font_size=24, tickfont_size=30,
                   tickangle=-35, title=None)
    p.update_yaxes(title="Band Gap [eV]", title_font_size=30,
                   tickfont_size=30)
    p.show('svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 120pt
#+attr_org: :width 640
[[file:./.ob-jupyter/55e458fa81a19544b854f8eb0141c77a857bf06b.svg]]
:end:

** Describing a Halide Perovskite                                  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** COMMENT compute pearson
#+begin_src jupyter-python
  bgdf = pd.concat(
      [Y.bg_eV[Y.LoT == 'PBE'].reset_index(drop=True),
       Y.bg_eV[Y.LoT == 'HSE'].reset_index(drop=True),
       Y.bg_eV[Y.LoT == 'HSE(SOC)'].reset_index(drop=True),
       Y.bg_eV[Y.LoT == 'HSE-PBErel(SOC)'].reset_index(drop=True),
       Y.bg_eV[Y.LoT == 'EXP'].reset_index(drop=True)],
      axis=1)
  bgdf.columns=['PBE bg', 'HSE bg', 'HSE(SOC) bg', 'HSE-PBErel(SOC) bg', 'EXP']
#+end_src

#+RESULTS:
:results:
:end:
  
#+begin_src jupyter-python
  wdf = pd.concat([bgdf, XX], axis=1).select_dtypes(np.number).fillna(0)
  pearson = pd.DataFrame(np.corrcoef(wdf, rowvar=False),
                         columns=wdf.columns,
                         index=wdf.columns)
#+end_src

#+RESULTS:
:results:
:end:

*** 14 Dimensional Chemical Vector                          :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.4
:END:
#+begin_src jupyter-python :post wrap(*this*, "170pt")
  sub = pearson.iloc[0:5, 5:17]
  p = px.imshow(sub, color_continuous_scale='RdBu_r', zmin=-1, zmax=1,
                labels=dict(color="Pearson Coefficient"),
                # y = ytitles,
                # height=300
                )
  p.update_xaxes(tickangle=-35, tickfont_size = 30)
  p.update_yaxes(tickangle=-35, tickfont_size = 30)
  p.update_layout(coloraxis=dict(colorbar=dict(len=1, orientation='h', y=0.8)))
  p.update_layout(
      # paper_bgcolor='rgba(255,255,255,0)',
      # plot_bgcolor='rgba(255,255,255,0)',
      margin=dict(t=0,b=0,l=0,r=0),
      font_size=20
  )
  p.update_layout(
      xaxis = dict(tickmode='array',
                   tickvals=list(range(sub.columns.shape[0])),
                   ticktext=sub.columns.str.slice(6).str.replace("'", "").str.replace("_"," ")
  ))
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 170pt
[[file:./.ob-jupyter/3f9092c825b142b1da90f67f4b672476f485574b.svg]]
:end:

*** Parsing compositions using =cmcl=                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.6
:END:
#+begin_src jupyter-python :exports src
  import cmcl
  Y = load_codomain_subset()
  df = Y.Formula.to_frame().ft.comp()
  df.index = Y.Formula
  print(df)
#+end_src

\begin{small}
\begin{verbatim}
                    FA   Pb   Sn    I   MA   Br
Formula                                        
FAPb_0.7Sn_0.3I_3  1.0  0.7  0.3  3.0  NaN  NaN
MAPb(I0.9Br0.1)3   NaN  1.0  NaN  2.7  1.0  0.3
\end{verbatim}
\end{small}

** Sample Space                                                    :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- t-SNE projection projects 14D composition vectors to 2D
- subset of domain has been previously sampled and is available to
  Mannodi reaserch group
  [cite:@yang-2023-high-throug]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+DOWNLOADED: screenshot @ 2023-05-19 13:44:52
#+attr_latex: :widh 200
[[file:Data/2023-05-19_13-44-52_screenshot.png]]

** Constituent Properties                                          :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** Twelve Properties per \(\ce{ABX_3}\) constituent              :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Ionic Radius
- Boiling Temperature
- Melting Temperature
- Density
- Atomic Weight
- Electron Affinity
**** col                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Ionization Energy
- Heat of Fusion
- Heat of Vaporization
- Electronegativity
- Atomic Number
- Period

*** non                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
compute by averaging elemental properties obtained from Mendeleev database
[cite:@mentel-2014]
by atomic weight of constituent in compount

** Bivariate Analysis of Functional Effects                        :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
# #+DOWNLOADED: screenshot @ 2023-05-19 12:18:44
# #+attr_latex: :width 380
# [[file:Data/2023-05-19_12-18-44_screenshot.png]]

#+begin_src jupyter-python :post wrap(*this*, "400pt")
  sub = pearson.iloc[0:5, 17:54]
  p = px.imshow(sub, color_continuous_scale='RdBu_r', zmin=-1, zmax=1,
                labels=dict(color="Pearson Coefficient"),
                height=400, width=900, aspect=1.5
                )
  p.update_xaxes(tickangle=-35, tickfont_size = 15)
  p.update_yaxes(tickangle=-35, tickfont_size = 15)
  p.update_layout(coloraxis=dict(colorbar=dict(len=1, orientation='h', y=1)))
  p.update_layout(
      # paper_bgcolor='rgba(255,255,255,0)',
      # plot_bgcolor='rgba(255,255,255,0)',
      margin=dict(t=0,b=0,l=0,r=0),
      font_size=20
  )
  p.update_layout(
      xaxis = dict(tickmode='array',
                   tickvals=list(range(sub.columns.shape[0])),
                   ticktext=sub.columns.str.slice(6).str.replace("'", "").str.replace("_"," ")
  ))
  p.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 400pt
[[file:./.ob-jupyter/936ea994119ed4e82dc02a3d1b1fd48bf89083da.svg]]
:end:

band gap at higher levels of theory correlate with composition differently[cite:@yang-2023-high-throug]

* Multi-Fidelity Learning
# challenges of learning from multiple fidelities
# compare to multi-task learning
# the model places more weight on different observations
# - I created yogi! place higher weight on EXP LoT while optimizing hyperparameters
# - oversampling is an alternative
# show uncertainties in GPR posterior over 5 plots
# Bootstrapping is
# show tables -- table showing effect of single-fideltiy training, effect of comp or prop exclusive
** Multi-fidelity Machine Learning                                 :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
\[
\hat{y}_i = y_i + \epsilon_i \mbox{ for observations } i=1,â€¦,N
\]

- high fidelity :: prior on variance is narrow
- low fidelity :: prior on variance is wide

*** Training Strategy                                             :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- oversampling
- weight scores to reward models faithful to higher fidelities
- sequential learning/delta learning
- co-Kriging

** Multi-Fidelity Model Development Workflow                       :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 300
[[file:~/Pictures/flowcharts/ML_pipe.png]]

Weightable Machine Learning pipeline implemented in Python
[cite:@manganaris-2022-mrs-comput]

* Models
# SLME improves on SQ to give us performant range of band gaps
# - accounts for additional energetic processes
# - dipole-allowed, dipole-forbidden, indirect band gap
# focus on EXP rmse -- I have the ability!
** COMMENT make subplots
*** rfr
#+begin_src jupyter-python
  data = pd.read_csv(os.path.expanduser('~/data/perovskites/rfr_pred.csv'), index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*)
  x='true'
  y='pred'
  p1 = px.scatter(
      data[data.partition=='test'],
      x=x, y=y,
      # facet_col='partition',
      hover_name="Formula",
      color="LoT"
  )
  p1.update_traces(
      marker_size=10.
      # marker_opacity=0.2,
      # selector={'marker_symbol':'circle'}
  )
  xlims = min(data[x]), max(data[y])
  ylims = min(data[y]), max(data[y])
  p1.add_scatter(x = [min(xlims+ylims), max(xlims+ylims)],
                y = [min(xlims+ylims), max(xlims+ylims)],
                mode='lines', name="parity", marker=dict(color="black"),
                row='all', col='all')
  p1.update_layout(title_text='Band Gaps [eV] (test partition)',
                  font_family='arial narrow', font_size=30,
                  margin=dict(t=70,b=0,l=0,r=0))
  p1.update_xaxes(title='DFT Calculation', constrain='domain', mirror = True)
  p1.update_yaxes(title='ML Prediction', scaleanchor='x', mirror=True)
  #p1.update_annotations(visible=False)
  p1.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 300pt
[[file:./.ob-jupyter/e30b34a286a15da2efbf0c8cf2dcfe208976a543.svg]]
:end:

*** gpr
#+begin_src jupyter-python
  data = pd.read_csv(os.path.expanduser('~/data/perovskites/gpr_pred.csv'), index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*)
  x='true'
  y='pred'
  p2 = px.scatter(
      data[data.partition=='test'],
      x=x, y=y,
      # facet_col='partition',
      hover_name="Formula",
      color="LoT"
  )
  p2.update_traces(
      marker_size=10.
      # marker_opacity=0.2,
      # selector={'marker_symbol':'circle'}
  )
  xlims = min(data[x]), max(data[y])
  ylims = min(data[y]), max(data[y])
  p2.add_scatter(x = [min(xlims+ylims), max(xlims+ylims)],
                y = [min(xlims+ylims), max(xlims+ylims)],
                mode='lines', name="parity", marker=dict(color="black"),
                row='all', col='all')
  p2.update_layout(title_text='Band Gaps [eV] (test partition)',
                  font_family='arial narrow', font_size=30,
                  margin=dict(t=70,b=0,l=0,r=0))
  p2.update_xaxes(title='DFT Calculation', constrain='domain', mirror = True)
  p2.update_yaxes(title='ML Prediction', scaleanchor='x', mirror=True)
  #p2.update_annotations(visible=False)
  p2.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 300pt
[[file:./.ob-jupyter/8207649382249cb7fc0bd9890e60c2be15801c8f.svg]]
:end:

*** sisso
#+begin_src jupyter-python
  data = pd.read_csv(os.path.expanduser('~/data/perovskites/sisso_pred.csv'), index_col=0)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :post wrap(*this*)
  x='true'
  y='pred'
  p3 = px.scatter(
      data[data.partition=='test'],
      x=x, y=y,
      # facet_col='partition',
      hover_name="Formula",
      color="LoT"
  )
  p3.update_traces(
      marker_size=10.
      # marker_opacity=0.2,
      # selector={'marker_symbol':'circle'}
  )
  xlims = min(data[x]), max(data[y])
  ylims = min(data[y]), max(data[y])
  p3.add_scatter(x = [min(xlims+ylims), max(xlims+ylims)],
                y = [min(xlims+ylims), max(xlims+ylims)],
                mode='lines', name="parity", marker=dict(color="black"),
                row='all', col='all')
  p3.update_layout(title_text='Band Gaps [eV] (test partition)',
                  font_family='arial narrow', font_size=30,
                  margin=dict(t=70,b=0,l=0,r=0))
  p3.update_xaxes(title='DFT Calculation', constrain='domain', mirror = True)
  p3.update_yaxes(title='ML Prediction', scaleanchor='x', mirror=True)
  #p3.update_annotations(visible=False)
  p3.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
 
#+attr_latex: :width 300pt
[[file:./.ob-jupyter/459743be84c705a5315e80fb969d28abdcad5600.svg]]
:end:

** Compare Three Methods                                           :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+begin_src jupyter-python :post wrap(*this*, w="430pt :options inkscapeformat=png, inkscapedpi=300")
  p0 = make_subplots(rows=1, cols=3, shared_yaxes=True)

  for trace1, trace2, trace3 in zip(p1.data, p2.data, p3.data):
      p0.add_trace(trace1, row=1, col=1) 
      p0.add_trace(trace2, row=1, col=2)
      p0.add_trace(trace3, row=1, col=3)

  import copy

  lo = copy.deepcopy(p0.layout)
  p0.update_layout(p2.layout)
  p0.update_layout(xaxis=p2.layout.xaxis, yaxis=p2.layout.yaxis, overwrite=False)
  p0.update_layout(xaxis2=p1.layout.xaxis, yaxis2=p1.layout.yaxis, overwrite=False)
  p0.update_layout(xaxis3=p3.layout.xaxis, yaxis3=p3.layout.yaxis, coloraxis=p3.layout.coloraxis, overwrite=False)
  p0.layout.xaxis2.scaleanchor=None
  p0.update_layout(lo, overwrite=False)
  # p0.update_layout(showlegend=False)
  p0.update_traces(showlegend=False, row=1, col=1)
  p0.update_traces(showlegend=False, row=1, col=2)

  # p1.update_xaxes(constrain='domain', row=1, col=2)
  p0.layout['yaxis2']['scaleanchor'] = 'x2'
  p0.layout['xaxis']['domain'] = [0.0, 0.30]
  p0.layout['xaxis2']['domain'] = [0.35, 0.65]
  p0.layout['xaxis3']['domain'] = [0.70, 1.0]

  p0.update_xaxes(tickvals=list(range(8)))
  p0.update_yaxes(title="RFR Prediction", row=1, col=1)
  p0.update_yaxes(title="GPR Prediction", title_standoff=0, row=1, col=2)
  p0.update_yaxes(title="SISSO Prediction", title_standoff=0, row=1, col=3)
  p0.update_layout(
      width=1500,
      # legend= dict(orientation='h', y=-0.5)
  )

  p0.update_traces(marker_line=dict(color = 'black', width = 1))

  p0.add_annotation(x=2.5, y=6, xref='x', yref='y',
                    text="r2 = 0.99<br>maxerr = 0.80<br>rmse = 0.12<br>", font_size=20,
                    showarrow=False)

  p0.add_annotation(x=2.5, y=6, xref='x2', yref='y',
                    text="r2 = 0.98<br>maxerr = 1.28<br>rmse = 0.15<br>", font_size=20,
                    showarrow=False)

  p0.add_annotation(x=2.5, y=6, xref='x3', yref='y',
                    text="r2 = 0.88<br>maxerr = 2.17<br>rmse = 0.47<br>", font_size=20,
                    showarrow=False)

  p0.show(renderer='svg')
#+end_src

#+RESULTS:
:results:
  [cite:@manganaris-2022-mrs-comput]
 
#+attr_latex: :width 430pt :options inkscapeformat=png, inkscapedpi=300
[[file:./.ob-jupyter/7908aac95025c52b8af6320709cb6d12ce1ce488.svg]]
:end:

** Scoring Performance                                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
| Score Categories  |      GPR |      RFR |    SISSO |
|-------------------+----------+----------+----------|
| rmse              | 0.156214 | 0.124738 | 0.474754 |
| rmse EXP          | 0.120475 | 0.154448 | 0.330080 |
| rmse PBE          | 0.128211 | 0.101872 | 0.395827 |
| rmse HSE          | 0.214920 | 0.152479 | 0.519706 |
| rmse HSE(SOC)     | 0.156785 | 0.108867 | 0.572644 |
| rmse HSE-PBE(SOC) | 0.130696 | 0.133027 | 0.470758 |

** SISSO Expression                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

\begin{align*}
bg\mbox{ [eV]} = 1.752393064 &((X;\mbox{electronegativity}*A;\mbox{heat of fusion})-(B;\mbox{electron affinity}+B;\mbox{ionization energy}))\nonumber\\+-0.5862929089 &((B;Sn-\mbox{HSE})+(\mbox{PBE}-X;\mbox{electronegativity}))\nonumber\\+1.063684923 &((A;\mbox{electronegativity}-B;Ca)*(B;\mbox{heat of vap}-X;\mbox{electron affinity}))\nonumber\\+4.657097107
\end{align*}

** COMMENT Interpreting Models                                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
** Shapely Additive Explanation (SHAP)                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
[cite:@lundberg-2017-unified-approac]

** SHAP Analyze RFR                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+DOWNLOADED: screenshot @ 2023-05-24 09:40:46
#+attr_latex: :width 350
[[file:Models/2023-05-24_09-40-46_screenshot.png]]

** SHAP Analyze GPR                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+DOWNLOADED: screenshot @ 2023-05-24 09:42:08
#+attr_latex: :width 350
[[file:Models/2023-05-24_09-42-08_screenshot.png]]

* Results
** Make Predictions on Domain Subset                               :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- desired range \(bg \in [1, 2.5]\) eV
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+DOWNLOADED: screenshot @ 2023-05-19 13:23:47
#+attr_latex: :width 200
[[file:Results/2023-05-19_13-23-47_screenshot.png]]

** Screening Yields                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+attr_latex: :width 120
[[file:screening_ops.png]]
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+DOWNLOADED: screenshot @ 2023-05-19 13:20:09
#+attr_latex: :width 260
[[file:Results/2023-05-19_13-20-09_screenshot.png]]

** Screened Constituent Frequencies                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:

#+DOWNLOADED: screenshot @ 2023-05-19 13:07:38
#+attr_latex: :width 400
[[file:Results/2023-05-19_13-07-38_screenshot.png]]
*** A-site                                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- prefer occupying small fraction mixing in most constituents
- \(\ce{K}\) and \(\ce{Rb}\) also prefer full occupancy

*** B-site                                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- favor full occupation a rate of 5-8%
- showed some preference approaching doping

*** X-site                                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- strongly prefer full occupation

** Interpretation                                                  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

#+DOWNLOADED: screenshot @ 2023-05-19 13:21:13
#+attr_latex: :width 200
[[file:Results/2023-05-19_13-21-13_screenshot.png]]

*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

#+DOWNLOADED: screenshot @ 2023-05-19 13:20:09
#+attr_latex: :width 200
[[file:Results/2023-05-19_13-20-09_screenshot.png]]

* COMMENT CGCNN
** CGCNN Introduction                                              :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- uses pymatgen to make crystal graphs
- predefined sets of features for every atom involved in computation
  [cite:@xie-2018-cryst-graph]

* COMMENT MEGnet
** MEGnet Introduction                                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- uses pymatgen to make crystal graphs
- invites use of custom feature sets
  [cite:@ward-2016-gener-purpos;@chen-2019-graph-networ]
- MFGnet capable of multi-fidelity regressions
  [cite:@chen-2021-learn-proper;@chen-2020-multi-fidel]

* COMMENT Ongoing work
** band gap learning curve                                         :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 250pt
[[file:/home/panos/data/alignn/dist_bg_32_100/lc.svg]]
# - uses cgcnn feature set
** band gap parity                                                 :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+attr_latex: :width 250
[[file:/home/panos/data/alignn/dist_bg_32_100/pp.svg]]
*** Score                                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.3
:END:
| partition |     rmse |
|-----------+----------|
| test      | 0.063789 |
| train     | 0.211039 |
** COMMENT Decomposition Energy learning curve                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 250
[[file:/home/panos/data/alignn/dist_de_32_100/lc.svg]]
** COMMENT Decomposition Energy parity                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+attr_latex: :width 250
[[file:/home/panos/data/alignn/dist_de_32_100/pp.svg]]
*** Score                                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.3
:END:
| partition |     rmse |
|-----------+----------|
| test      | 0.012009 |
| train     | 0.081978 |

* Summary and Conclusions
** Review of Work                                                  :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- preexisting data set of ~500 samples from domain of ~40000 single-site mixed compositions
- extract features using =cmcl=
- train models of band gaps measured at multiple fidelities
- ascertain best model
- analyze model accuracy, interpretability of bias and variance
- make predictions on whole sample domain
- Screen for viable candidate compositions

** Conclusions                                                     :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- RFR yields the best model because
  - it captures relevant feature interactions as corroborated by Pearson correlations
  - it flexibly represents nonlinear relationships between feature interactions and band gap
  - as an ensemble model, it reduces the variance of error
- SISSO is remarkably accurate for its simplicity but it is limited
  for high fidelity predictions due to the absence of some fidelity
  variables
- GPR has potential for further study alongside graph neural networks
* Credit
** Acknowledgements                                                :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
**** Research Group                                              :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
I am grateful to
- Professor Arun Mannodi-Kanakkithodi for his mentorship, support, and knowledge.
- Professor Erk for her guidance and council
- Professor Strachan for his instruction
- Jiaqi Yang for his collaboration
- Habibur Rahman for his friendship and curiosity
**** COMMENT Experimental Collaborators                          :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Thanks to Professor David Fenning, Dr. Rishi Kumar for working with us
to validate simulations and predictions.
**** Funding                                                     :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- Ross Fellowship
- Professor Arun's startup research grant
# F.10023800.05.002
**** Resources                                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
RCAC Bell Computing Cluster
*** col                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+LATEX: \hspace*{-1cm}
#+attr_latex: :width 200 :center nil
[[file:~/Pictures/mrg-photoshoot/41_Kanakkithodi.jpg]]
* Bib
** References                                                      :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:BEAMER_opt: allowframebreaks
:END:
#+LATEX:\AtNextBibliography{\tiny}
#+LATEX:\printbibliography
* SI                                                             :B_appendix:
:PROPERTIES:
:BEAMER_env: appendix
:END:
** Data Pre-Processing                                             :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
#+attr_latex: :width 300
[[file:~/Pictures/flowcharts/data_proc.png]]
Data pre-processing Workflow to Implement with Python Pandas
** DFT Functionals Effect Band Structure Calculation in HaPs       :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
- D3
- SOC
- PBE semi-local vs HSE hybrid
  - (effects on electronic structure)
  - computational heft
* Footnotes

[fn:2]\tiny{}[[https://www.lesker.com/newweb/ped/applications/perovskite-research.cfm ][www.lesker.com]]
[fn:1]\tiny{}Photo by Dennis Schroeder\newline{}National Renewable Energy Laboratory

# :var c=""
# \n#+CAPTION: $c
#+NAME: wrap
#+begin_src bash :var p="" :var w="300pt"
  echo -ne "$p \n#+attr_latex: :width $w"
#+end_src

#+NAME: wraptbl
#+begin_src bash :var p="" :var w="300pt" :var c=""
  echo -ne "$p \n#+CAPTION: $c "
#+end_src
